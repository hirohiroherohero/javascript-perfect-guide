## 6.1 객체 소개

1. 객체는 복합된 값이다.

    - 객체는 여러 가지 값(기본 값이나 다른 객체)을 모아서 이름을 통해 값을 저장하고 가져올 수 있게한다.
    - 객체는 프로퍼티의 순서 없는 집합이며 각 프로퍼티에는 이름과 값이 있다.
        - 프로퍼티의 이름은 보통 문자열이다.
    - 하지만, 객체는 단순히 문자열과 값을 연결한 것이 아니다.
        - 자바스크립트 객체는 자신만의 프로퍼티를 가지는 것 외에도, ‘프로토타입’으로 불리는 다른 객체에서 프로퍼티를 상속하기도 한다.
        - 객체의 메서드는 일반적으로 상속된 프로퍼티이며 이 ‘프로토타입 상속’이 자바스크립트의 중요한 기능이다.

1. 자바스크립트 객체는 동적이기 때문에 일반적으로 프로퍼티를 추가하거나 삭제할 수 있다.

    - 대신 정적인 객체를 흉내 낼 수도 있고 정적 타입을 사용하는 언어의 구조 역시 사용할 수 있다.

1. 객체는 가변이며 값이 아닌 참조로 조작한다.

    ```jsx
    let x = { a: 1 };

    let y = x;
    ```

    - 변수 y는 변수 x의 객체 사본이 아니라 같은 객체를 참조한다.
        - 변수 y를 통해 객체를 수정하면 그 결과는 변수 x에도 똑같이 적용된다.

1. 객체를 통해 하는 일에는 생성, 검색, 삭제, 테스트, 프로퍼티 열거로 나눌 수 있다.

1. 프로퍼티에는 이름과 값이 있다.

    - 프로퍼티 이름에는 빈 문자열과 심벌을 포함해 어떤 문자열이든 쓸 수 있지만, 같은 이름의 프로퍼티는 존재할 수 없다.
    - 값은 타입을 가리지 않는 자바스크립트 값이며, `getter`와 `setter`, 또는 둘 다가 될 수 있다.

1. 객체에서 직접 정의한 프로퍼티와 프로토타입 객체에서 상속한 프로퍼티를 구별하는 것이 중요할 때도 있다.
    - 상속되지 않는 프로퍼티를 자체 프로퍼티(`own property`)라고 부른다.
    - 모든 프로퍼티에는 이름과 값 외에도 세가지 프로퍼티 속성이 있다.
        - 쓰기가능 속성
            - 프로퍼티에 값을 설정할 수 있는지 없는지를 나타낸다.
        - 열거가능 속성
            - `for/in` 루프에 프로퍼티 이름을 반환할지 안 할지를 나타낸다.
        - 변경가능 속성
            - 프로퍼티를 삭제할 수 있는지 없는지, 속성을 바꿀 수 있는지 없는지를 나타낸다.
    - 자바스크립트의 내장 객체의 프로퍼티 중 상당수는 읽기 전용이거나 열거 불가, 변경 불가이다.
    - 자체 프로퍼티는 기본적으로 쓰기 가능, 열거 가능, 변경 가능이다.

## 6.2 객체 생성

1. 객체를 생성할 때는 객체 리터럴, `new` 키워드, `Object.create()` 함수를 사용한다.

### 6.2.1 객체 리터럴

1. 객체를 생성하는 가장 쉬운 방법이다.

    ```jsx
    const x = { a: 1, b: 2 };
    ```

    - 프로퍼티 이름은 자바스크립트 식별자 또는 문자열 리터럴이고, 빈 문자열도 허용한다.
    - 프로퍼티 값은 자바스크립트 표현식이면 무엇이든 가능하다.

    ```jsx
    let empty = {};
    let point = { x: 0, y: 0 };
    let p2 = { x: point.x, y: point.y + 1 };
    let book = {
        "main title": "JavaScript",
        "sub-title": "The Definitive Guide",
        for: "all audiences", // for는 예약어지만 사용 가능
        author: {
            firstname: "David",
            surname: "~~~~",
        },
    };
    ```

1. 객체 리터럴을 평가할 때마다 새 객체가 만들어진다.
    - 각 프로퍼티의 값 역시 리터럴을 평가할 때마다 평가된다.
    - 따라서, 객체 리터럴 자체가 바뀌지 않더라도 반복적으로 호출되는 함수나 루프 바디 안에 있다면 새 객체를 여러 개 만들 수 있으며, 이 객체들의 프로퍼티 값 역시 매번 달라질 수 있다.

### 6.2.2 new

1. `new` 연산자
    - 새 객체를 생성하고 초기화한다.
    - `new` 키워드 뒤에는 반드시 함수 호출이 있어야 한다.
    - 이런 형태로 사용하는 함수를 생성자라고 한다.
        - 자바스크립트 내장 타입에도 생성자가 있다.
        ```jsx
        let o = new Object(); // 빈 객체를 만든다. {}와 같다.
        let a = new Array(); // 빈 배열을 만든다. []와 같다.
        let d = new Date(); // 현재 시간을 나타내는 Date 객체를 만든다.
        let r = new Map(); // 키와 값을 연결하는 Map 객체를 만든다.
        ```

### 6.2.3 프로토 타입

1. 자바스크립트 객체 거의 대부분은 자신과 연결된 두 번째 객체를 갖는다.
    - 여기서 두 번째 객체를 프로토타입이라 부른다.
    - 첫 번째 객체는 프로토타입에서 프로퍼티를 상속한다.
2. 객체의 생성 방법 별 프로토타입

    - 객체 리터럴을 사용해 생성한 객체
        - 모두 같은 프로토타입 객체를 갖는다.
        - 이 프로토타입 객체는 `Object.prototype` 이라는 코드로 참조할 수 있다.
    - `new` 키워드와 생성자를 사용해 만든 객체
        - 생성자 함수의 `prototype` 프로퍼티 값을 자신의 프로토타입으로 사용한다.
            - `new Object()`로 생성한 객체의 프로토타입은 `{}` 로 생성한 객체와 마찬가지로 `Object.prototype`이다.
            - `new Array()`를 사용해 생성된 객체의 프로토타입은 `Array.prototype`이다.
            - `new Date()`를 사용해 생성된 객체의 프로토타입은 `Date.prototype`이다.

3. 거의 모든 객체에 프로토타입이 있지만, `prototype` 프로퍼티가 있는 객체는 비교적 적다.
    - `prototype` 프로퍼티를 갖는 객체가 다른 객체의 프로토타입을 정의한다.
    - `Object.prototype`은 프로토타입이 없는 드문 객체 중 하나다.
        - 이 객체는 어떤 프로퍼티도 상속하지 않는다.
    - 다른 프로토타입 객체는 일반적인 객체이며 역시 프로토타입이 있다.
    - 내장 생성자 대부분에 (대부분의 사용자 정의 생성자 역시) `Object.prototype`에서 프로퍼티를 상속하므로 `new Date()`로 생성한 `Date` 객체는 `Date.prototype`와 `Object.prototype` 양쪽에서 프로퍼티를 상속합니다.
        - 이렇게 이어지는 프로토타입 객체 사이의 연결을 프로토타입 체인이라 부른다.

### 6.2.4 Object.create()

1. `Object.create()`

    - `Object.create()`는 첫 번째 인자를 프로토타입 삼아 새 객체를 생성한다.

    ```jsx
    let o = Object.create({ x: 1, y: 2 }); // o1은 x와 y프로퍼티를 상속한다.
    ```

    - 인자로 `null`을 전달해 프로토타입이 없는 객체를 생성할 수도 있지만, 이렇게 생성된 객체는 아무것도 상속하지 않으며 기본 메서드조차 없다.
    - `{}`나 `new Object()`가 반환하는 것처럼 일반적인 빈 객체를 만들고 싶을 때는 `Object.prototype`을 전달한다.

    ```jsx
    let o = Object.create(Object.prototype);
    ```

1. `Object.create()`을 사용하는 목적
    - 서드 파티 라이브러리에서 객체를 변경하는 사고를 막는 것!!
        - 객체를 라이브러리 함수에 전달하지 않고 원래 객체를 상속하는 객체를 전달하면, 그 함수는 아무 문제 없이 상속된 값을 읽을 수 있다.
        - 라이브러리에서 부주의하게 프로퍼티 값을 바꾸더라도 원래 객체에는 영향이 없다.

## 6.3 프로퍼티 검색과 설정

1. 프로퍼티 값에 접근 할 때는 점(`.`)이나 대괄호(`[]`) 연산자를 사용한다.

    - 점 연산자를 사용한다면 오른쪽은 반드시 프로퍼티 이름인 단순한 식별자여야 한다.
    - 대괄호 연산자를 사용한다면 그 안에 있는 값은 원하는 프로퍼티 이름인 문자열로 평가되는 표현식이어야 한다.

1. 프로퍼티를 생성하거나 설정할 때도 마찬가지로 점(`.`)이나 대괄호(`[]`) 연산자를 사용하고, 이들을 할당 표현식 왼쪽에 써야 한다.

### 6.3.1 연관 배열인 객체

1. `object[”property”]`

    - 마치 숫자가 아닌 문자열로 인덱스된 배열에 접근하는 것처럼 대괄호 안에 문자열을 사용했다.
        - 문자열을 인덱스로 사용하는 배열을 연관 배열 이라고 부른다.

1. 프로퍼티 검색 중 대괄호 연산자
    - C,C++,자바 등 타입이 고정된 언어에서는 객체의 프로퍼티 개수가 고정되어 있으며, 프로퍼티 이름 역시 반드시 미리 정의되어 있어야 한다.
        - 하지만 자바스크립트는 타입을 엄격하게 고정하지 않으므로 이런 규칙이 없다.
    - 점 연산자를 사용해 객체프로퍼티에 접근할 때 프로퍼티 이름은 식별자로 표현된다.
        - 식별자는 반드시 문자 그대로 프로그램에 입력해야한다.
        - 식별자는 데이터 타입이 아니므로 프로그램에서 조작할 수 없다.
    - 대괄호 연산자는 객체 프로퍼티에 접근할 때는 프로퍼티 이름을 문자열로 표현한다.
        - 문자열은 자바스크립트 데이터 타입이므로, 프로그램이 실행되는 동안 새로 생성할 수도 있고 조작할 수도 있다.
        ```jsx
        let addr = "";
        for (let i = 0; i < 4; i++) {
            addr += customer[`address${i}`] + "\n";
        }
        ```
        - 대괄호 연산자는 동적이고 런타임에 바꿀 수 있는 문자열 값을 사용한다.
        ```jsx
        function addstock(portfolio, stockname, shares) {
            portfolio[stockname] = shares;
        }
        ```

### 6.3.2 상속

1. 자바스크립트 객체에는 자체 프로퍼티도 있고, 프로토타입 객체에서 상속하는 프로퍼티도 있다.

1. 예시) 객체 `o`의 `x`프로퍼티를 가져온다고 가정!

    - `o`에 `x`라는 자체 프로퍼티가 없다면?
        - `o`의 프로토타입 객체에서 `x`프로퍼티를 검색한다.
    - 프로토타입 객체에도 자체프로퍼티 `x`는 없지만 프로토타입이 있다면?
        - 프로토타입의 프로토타입에서 해당 프로퍼티를 검색한다.
    - `x`프로퍼티를 찾거나, 프로토타입이 `null`인 객체에 도달할 때 까지 검색을 계속한다.
    - 객체의 `prototype` 속성은 자신이 어디에서 프로퍼티를 상속했는지 나타내는 체인을 형성한다.

    ```jsx
    let o = {}; // o는 Object.prototype에서 객체 메서드를 상속한다.
    o.x = 1; // 자체 프로퍼티 x 생성
    let p = Object.create(o); // p는 o와 Object.prototype에서 프로퍼티를 상속한다.
    p.y = 2; // 자체 프로퍼티 y 생성
    let q = Object.create(p); // q는 p와 o와 Object.prototype에서 프로퍼티를 상속한다.
    q.z = 3; // 자체 프로퍼티 z 생성
    let f = q.toString(); // toString()은  Object.prototype에서 상속함.
    q.x + q.y; // => 3 x와 y는 o와 p에서 상속함.
    ```

1. 예시) 객체 `o`의 `x`프로퍼티에 값을 할당한다고 가정!

    - `o`에 이미 자체 (상속되지 않은) `x`프로퍼티가 있다면?
        - 그 할당은 기존 프로퍼티의 값을 바꾼다.
    - 그렇지 않다면?
        - 객체 `o`에 `x`프로퍼티를 새로 만들고 거기에 할당한다.
    - `o`에 상속된 프로퍼티 `x`가 있었다면?
        - 상속된 프로퍼티는 이제 새로 생성된 자체 프로퍼티에 ‘가려진다.’
    - 프로퍼티 할당은 프로토타입 체인을 검색해 할당이 허용되는지 확인한다.
        - `o`가 읽기 전용인 `x`프로퍼티를 상속한다면 할당은 허용되지 않는다.
        - 하지만 할당이 허용된다면 항상 원래 객체의 프로퍼티를 생성하거나 설정할 뿐, 프로토타입 체인에 존재하는 객체는 절대 수정하지 않는다.
        - 프로퍼티를 검색할 때는 상속을 감안하지만 설정할 때는 그렇지 않으므로 상속된 프로퍼티도 덮어 쓸 수 있다.

1. 프로퍼티 할당은 실패하거나, 아니면 원래 객체에 프로퍼티를 생성 또는 설정한다는 규칙에는 한가지 예외가 있다.
    - `o`가 `x`프로퍼티를 상속하고 그 프로퍼티가 세터 메서드가 있는 접근자 프로퍼티라면?
        - `o`에 `x`프로퍼티를 새로 만드는 대신 세터 메서드를 호출한다.
    - 하지만, 세터 메서드는 객체 `o`에 호출되는 것이지 해당 프로퍼티를 정의한 프로토타입 객체에 호출되는 것이 아니므로, 세터 메서드가 프로퍼티를 변경하더라도 `o`에 변화가 있을 뿐 프로토타입 체인은 변하지 않는다.

### 6.3.3 프로퍼티 접근 에러

1. 접근 에러

    - 존재하지 않는 프로퍼티를 검색하는 것은 에러가 아니다
        - `o`의 자체 프로퍼티나 상속된 프로퍼티에서 `x`프로퍼티를 찾지 못한다면 `undefined`로 평가된다.
        ```jsx
        book.subtitle; // => undefined: 프로퍼티가 존재하지 않습니다.
        ```
    - 존재하지 않는 객체의 프로퍼티를 검색하려 하는 것은 에러이다.
        - `null`과 `undefined`에는 프로퍼티가 없고 이런 값에서 프로퍼티를 검색하려 하는 것은 에러다.
        ```jsx
        book.subtitle.length; // TypeError: undefined에는 length 프로퍼티가 없습니다.
        ```
    - `null`이나 `undefined`의 프로퍼티를 설정하려 해도 TypeError가 일어난다.

1. 프로퍼티 할당이 실패할때 ( 객체 `o`에 프로퍼티 `p`를 설정하려는 시도 )
    - `o`에 자체 프로퍼티 `p`가 있고 읽기 전용일 때
        - 읽기 전용 프로퍼티의 값은 바꿀 수 없다.
    - `o`에 상속된 프로퍼티 `p`가 있고 읽기 전용일 때
        - 상속된 읽기 전용 프로퍼티를 같은 이름의 자체 프로퍼티로 가릴 수 없다.
    - `o`에 자체 프로퍼티 `p`가 없으며 세터 메서드로 프로퍼티 `p`를 상속하지 않고 `o`의 확장 가능 속성이 `false`일 때
        - `p`는 `o`에 존재하지 않고 호출할 세터 메서드도 없으므로 `p`를 `o`에 추가해야 하지만, `o`는 확장 불가이므로 새 프로퍼티를 설정할 수 없다.

## 6.4 프로퍼티 삭제

1. `delete` 연산자는 객체에서 프로퍼티를 삭제한다.

    - 피연산자는 프로퍼티 접근 표현식이여야 한다.
    - 값을 삭제하는 것이 아니라 프로퍼티 자체를 삭제한다.

1. `delete` 연산자는 자체 프로퍼티만 삭제할 뿐 상속된 프로퍼티는 삭제하지 않는다.

    - 상속된 프로퍼티를 삭제하려면 반드시 해당 프로퍼티를 정의한 프로토타입 객체에서 삭제해야 한다.
    - 이렇게 하면 해당 프로토타입을 상속한 객체 전체에 영향을 미친다.

1. `delete` 표현식은 삭제에 성공했을 때, 또는 존재하지 않는 프로퍼티 삭제를 시도하는 등 효과가 없었을 때 `true`로 평가된다.

    - `delete` 는 프로퍼티 접근 표현식이 아닌 표현식을 사용했을 때도 (아무 의미 없지만) `true`로 평가된다.

1. `delete` 는 변경 가능 속성이 `false`인 프로퍼티는 제거하지 않는다.
    - 내장 객체의 일부 프로퍼티, 변수 선언이나 함수 선언으로 생성된 전역 객체의 프로퍼티는 변경 불가이다.
    - 스트릭트 모드에서는 변경 불가인 프로퍼티를 삭제하려 하면 `TypeError`가 일어난다.
    - 일반 모드에서는 에러가 일어나지않고 `false`로 평가된다.

## 6.5 프로퍼티 테스트

1. 자바스크립트 객체는 프로퍼티 집합으로 볼 수 있으며, 주어진 이름을 가진 프로퍼티가 객체에 존재하는지 확인해야 할 때가 있다.

    - 이 경우 `in` 연산자, `hasOwnProperty()`, `propertyIsEnumerable()` 메서드를 사용하거나 그냥 프로퍼티를 검색하면 된다.

1. `in` 연산자는 왼쪽에 프로퍼티 이름, 오른쪽에 객체를 예상한다.

    - 객체에 그런 이름을 가진 자체 프로퍼티나 상속된 프로퍼티가 있다면 `true`를 반환한다.

    ```jsx
    let o = { x: 1 };

    "x" in o; // true
    "y" in o; // false
    "toString" in o; // true
    ```

1. `hasOwnProperty()` 메서드는 객체에 주어진 이름을 가진 자체 프로퍼티가 있는지 테스트 한다.

    - 상속된 프로퍼티에는 `false`를 반환한다.

    ```jsx
    let o = { x: 1 };

    o.hasOwnProperty("x"); // true
    o.hasOwnProperty("y"); // false
    o.hasOwnProperty("toString"); // false
    ```

1. `propertyIsEnumerable()` 은 `hasOwnProperty()` 를 더 제한한 버전이다.

    - 이 메서드는 지정된 프로퍼티가 자체 프로퍼티이며 열거 가능 속성이 true일 때만 true를 반환한다.
    - 일부 내장 프로퍼티는 열거 불가이다.
    - 일반적인 자바스크립트 코드로 생성한 프로퍼티는 모두 열거 가능이다.

    ```jsx
    let o = { x: 1 };

    o.propertyIsEnumerable("x"); // true
    o.propertyIsEnumerable("toString"); // false
    Object.prototype.propertyIsEnumerable("toString"); // false
    ```

1. `in` 연산자 대신 그냥 프로퍼티를 검색하고 `!==` 를 써서 `undefined`가 아님을 확인해도 된다.

    ```jsx
    let o = { x: 1 };

    o.x !== undefined; // true
    o.y !== undefined; // false
    o.toString !== undefined; // true
    ```

1. `in`은 존재하지 않는 프로퍼티와 존재하지만 값이 `undefined` 인 프로퍼티를 구분할 수 있다.

    ```jsx
    let o = { x: undefined };

    o.x !== undefined; // false
    o.y !== undefined; // false
    x in "o"; // true
    y in "o"; // false
    delete o.x;
    x in "o"; // false
    ```

## 6.6 프로퍼티 열거

1. 객체의 프로퍼티 전체를 순회해야 할 때!

    - `for/in` 루프는 지정된 객체의 상속 여부를 구분하지 않고 열거 가능 프로퍼티마다 그 이름을 루프 변수에 할당하면서 루프 바디를 실행한다.

        - 객체가 상속하는 내장 메서드는 열거 불가이지만, 우리가 추가한 프로퍼티는 기본적으로 열거 가능이다.

        ```jsx
        let o = { x: 1, y: 2, z: 3 };

        o.propertyIsEnumerable("toString"); // false
        for (let p in o) {
            console.log(p);
        }
        ```

        - `for/in` 에서 상속된 프로퍼티가 열거되는 것을 막을 때는 명시적으로 체크해야한다.

        ```jsx
        for (let p in o) {
            if (!o.hasOwnProperty(p)) continue; // 상속된 프로퍼티는 건너뛴다.
        }

        for (let p in o) {
            if (typeof o[p] === "function") continue; // 메서드는 건너뛴다.
        }
        ```

    - `for/in` 루프를 사용하는 것보다 객체의 프로퍼티 이름을 배열에 저장해서 `for/of` 루프를 사용하는 것이 더 쉽다.
        - `Object.keys()` 는 객체의 열거 가능한 자체 프로퍼티 이름을 배열로 반환한다. 이 메서드는 열거 불가 프로퍼티, 상속된 프로퍼티, 이름이 심벌인 프로퍼티는 내보내지 않는다.
        - `Object.getOwnPropertyNames()` 는 `Object.keys()` 와 비슷하지만, 이름이 문자열이기만 하면 열거 불가인 자체 프로퍼티 이름도 배열로 반환한다.
        - `Object.getOwnPropertySymbols()` 는 열거 가능 여부를 따지지 않고 이름이 심벌인 자체 프로퍼티를 배열로 반환한다.
        - `Reflect.ownKeys()` 열거 가능 여부를 따지지 않고, 문자열인지 심벌인지 구분 하지 않고 자체 프로퍼티 이름은 전부 배열로 반환한다.

    ### 6.6.1 프로퍼티 열거 순서

    1. 객체의 자체 프로퍼티를 열거하는 순서는 ES6에서 공식적으로 정의했다.

        - `Object.keys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbols(), Reflect.ownKeys(), JSON.stringify()`등 관련 메서드는 다음 순서에 따라 프로퍼티를 열거한다.
        - 또한 열거 불가 프로퍼티를 반환하는지, 프로퍼티 이름이 문자열인지 심벌인지에 따른 제한이 함께 적용된다.
            1. 이름이 음이 아닌 정수인 문자열 프로퍼티가 첫 번째로 나열되며 작은 수에서 큰 수 순으로 열거된다. 따라서 배열 및 배열 비슷한 객체의 프로퍼티도 순서대로 열거된다.
            2. 배열 인덱스와 비슷한 프로퍼티를 모두 열거한 다음에는 음수나 부동 소수점 숫자처럼 보이는 프로퍼티를 포함해 이름이 문자열인 프로퍼티를 열거한다. 이 프로퍼티는 객체에 추가된 순서대로 열거된다. 객체 리터럴로 정의된 프로퍼티는 리터럴에 쓰인 순서를 따른다.
            3. 마지막으로, 이름이 심벌인 프로퍼티를 객체에 추가된 순서대로 열거한다.

    1. `for/in` 루프의 열거 순서는 이 열거 함수만큼 정확하게 정의되어 있지는 않지만, 대부분의 실행 환경에서 자체 프로퍼티를 위에 설명한 순서대로 열거하고 프로토타입 체인을 따라 올라가면서 각 프로토타입 객체에 대해 열거 가능한 프로퍼티를 같은 순서로 열거한다.
        - 하지만 같은 이름의 프로퍼티가 이미 열거됐다면 열거하지 않으며, 이미 고려된 프로퍼티 중 같은 이름의 열거 불가 프로퍼티가 있었다면 열거하지 않는다.

## 6.7 객체 확장

1. 자바스크립트 프로그램에서 객체의 프로퍼티를 다른 객체에 복사하는 것은 흔한 일이다.

    ```jsx
    let target = { x: 1 },
        source = { y: 2, z: 3 };

    for (let key of Object.keys(source)) {
        target[key] = source[key];
    }

    target; // => { x: 1, y: 2, z: 3}
    ```

1. ES6에서는 이런 기능을 `Object.assign()`이라는 이름으로 자바스크립트 코어에 도입했다.

1. `Object.assign()`

    - `Object.assign()` 은 인자로 두 개 이상의 객체를 받는다.
        - 첫번째 인자는 수정해서 반환할 대상 객체이다.
        - 두번째 또는 그 이후의 인자는 수정하지 않는 소스 객체이다.
    - 각 소스 객체의 열거 가능한 자체 프로퍼티를(이름이 심벌인 것을 포함해) 대상 객체에 복사한다.
        - 복사할 때 소스 객체를 인자 순서대로 처리하는데, 첫번째 소스 객체의 프로퍼티는 대상 객체에 있는 같은 이름의 프로퍼티를 덮어쓴다.
        - 두번째 소스 객체가 있다면 그 객체의 프로퍼티가 첫번째 소스 객체에 있는 같은 이름의 프로퍼티를 덮어 쓴다.
    - 소스 객체에 게터 메서드가 있거나 대상 객체에 세터 메서드가 있다면 복사 도중에 이들이 호출되긴 하지만 메서드 자체를 복사하지는 않는다.
    - 프로퍼티를 객체에서 다른 객체로 복사하는 이유 중 하나는 소스 객체에 기본 값을 정의해 두고 대상 객체에 그런 이름이 존재하지 않는다면 복사해서 쓰려는 목적이다.

1. 사용법

    ```jsx
    Object.assign(o, default) // o를 전부 default로 덮어 쓴다. 예상하지 못한 결과가 나올 수 있다.

    let o = Object.assign({}, default) // 새 객체를 생성하고 기본 값을 복사한 다음, 이 기본 값을 o의 프로퍼티로 덮어 쓴다.

    o = {...default, ...o} // 분해 연산자를 통해서도 가능하다.
    ```

1. `Object.assign()` 의 변형

    - 만약 존재하지 않는 프로퍼티만 복사하도록 `Object.assign()` 을 변형해 사용하면 객체를 새로 만들어 복사해야 하는 부담을 줄일 수 있다.

    ```jsx
    function merge(target, ...sources) {
        for (let source of sources) {
            for (key of Object.keys(source)) {
                if (!(key in target)) {
                    // Object.assign()과 다른점
                    target[key] = source[key];
                }
            }
        }

        return target;
    }
    ```

## 6.8 객체 직렬화

1. 객체 직렬화
    - 객체를 문자열로 변환하는 작업이다.
        - 이 문자열은 나중에 다시 객체로 되돌릴 수 있다.
2. `JSON.stringify()`와 `JSON.parse()`는 자바스크립트 객체를 직렬화하고 되돌리는 함수이다.
    - 이 함수는 데이터 교환 형식인 `JSON`을 사용한다.
        - `JSON`은 ‘자바스크립트 객체 표기법(`JavaScript Object Nota-tion`)’의 약어이다.
3. `JSON` 문법은 자바스크립트 문법의 부분 집합이며 자바스크립트 값 전체를 표현하지는 못한다.
    - 객체, 배열, 문자열, 유한한 숫자, `true`, `false`, `null`은 모두 지원되고 직렬화하 복원이 가능하다.
    - `NaN`, `Infinity`, `-Infinity`는 `null`로 직렬화된다.
    - `Date` 객체는 `ISO` 형식 날짜 문자열로 직렬화되지만 `JSON.parse()`는 이 문자열을 그대로 문자열로 둘 뿐 `Date` 객체로 복원하지는 않는다.
    - 함수, `RegExp`, `Error` 객체, `undefined` 값은 직렬화하거나 복원할 수 없다.
    - `JSON.parse()`는 열거 가능한 자체 프로퍼티만 직렬화하기 때문에 프로퍼티 값을 직렬화할 수 없다면 해당 프로퍼티는 결과 문자열에서 생략된다.
    - `JSON.stringify()`와 `JSON.parse()`는 모두 직렬화와 복원 방법을 지정하는 두 번째 인자를 선택사항으로 받을 수 있다.
        - 이 인자에는 직렬화에 포함할 프로퍼티 리스트, 직렬화에 사용할 값 등을 지정할 수 있다.

## 6.9 객체 메서드

1. 명시적으로 프로토타입 없이 생성한 객체를 제외하면 자바스크립트 객체는 모두 Object.prototype에서 프로퍼티를 상속한다.
    - 상속되는 프로퍼티는 대부분 메서드이며 어디서든 사용할 수 있다.

### 6.9.1 toString() 메서드

1. `toString()` 메서드에는 인자가 없다.

    - 이 메서드는 호출한 객체의 값을 나타내는 문자열로 반환한다.

1. 기본 `toString()` 메서드는 별로 도움이 되지 않는다.

    ```jsx
    let s = { x: 1, y: 1 }.toString(); // "[object, Object]"
    ```

    - 기본 메서드에서 유용한 정보를 제공하지 않으므로 여러 클래스에서 자신만의 `toString()`을 정의하곤 한다.
        ```jsx
        let point = {
            x: 1,
            y: 1,
            toString: function () {
                return `${this.x}, ${this.y}`;
            },
        };

        String(point); // => "(1,2)" 문자열로 변환할 때  toString()을 호출한다.
        ```

### 6.9.2 toLocaleString() 메서드

1. 이 메서드의 목적은 지역에 맞는 문자열 표현을 반환하는 것이다.

    - 하지만 `Object` 에 정의된 기본 `toLocaleString()` 메서드 자체에는 지역화 기능이 전혀 없고, 그저 `toString()`을 호출해 그 값을 반환하기만 한다.
    - Date와 숫자 클래스에는 숫자, 날짜, 시간을 지역의 관습에 맞게 표현하는 `toLocaleString()`이 있다.

    ```jsx
    let point = {
        x: 1000,
        y: 2000,
        toString: function () {
            return `${this.x}, ${this.y}`;
        },
        toLocaleString: function () {
            return `${this.x.toLocaleString()}, ${this.y.toLocaleString()}`;
        },
    };

    point.toString(); // => "(1000, 2000)"
    point.toLocaleString(); // => "(1,000, 2,000)"
    ```

### 6.9.3 valueOf() 메서드

1. `valueOf()` 메서드는 `toString()` 메서드와 비슷하지만, 객체의 문자열이 아닌 다른 기본 타입, 보통은 숫자로 변환하려 할 때 호출한다.

    - 자바스크립트는 기본 값을 예상하는 곳에 객체를 사용하면 자동으로 이 메서드를 호출한다.

1. 기본 `valueOf()` 메서드는 별 도움이 되지 않지만 내장 클래스 중에 `valueOf()` 메서드를 따로 정의 한 것도 있다.
    - `Date` 클래스의 `valueOf()` 는 날짜를 숫자로 변환하므로, `Date` 객체는 `<` 와 `>` 를 사용해 시간 순서로 비교할 수 있다.

### 6.9.4 toJSON() 메서드

1. `Object.prototype`에 실제로 toJSON() 메서드가 정의된 것을 아니지만, `JSON.stringify()` 메서드는 직렬화할 객체에서 `toJSON()` 메서드를 검색한다.

## 6.10 확장된 객체 리터럴 문법

1. 자바스크립트 최근 버전에서는 객체 리터럴 문법을 여러 가지 방법으로 확장했다.

### 6.10.1 단축 프로퍼티

1. 변수 x와 y에 값을 저장했고, 객체의 x와 y 프로퍼티에도 그 값을 할당하고 싶을때!
    - 기본적인 객체 리터럴 문법을 사용
        ```jsx
        let x = 1,
            y = 2;
        let o = {
            x: x,
            y: y,
        };
        ```
    - ES6 이후
        ```jsx
        let x = 1,
            y = 2;
        let o = { x, y };
        ```

### 6.10.2 계산된 프로퍼티 이름

1. 특정 프로퍼티가 있는 객체를 만들어야 하는데, 프로퍼티 이름이 소스 코드에 문자 그대로 입력할 수 있는 컴파일 타임 상수가 아니라 변수에 저장되어 있거나 함수의 반환 값일 때가 있을때!
    - 객체를 만들고 프로퍼티를 추가
        ```jsx
        const PROPERTY_NAME = "p1";
        function computePropertyName() {
            return "p" + 2;
        }

        let o = {};
        o[PROPERTY_NAME] = 1;
        o[computePropertyName()] = 2;
        ```
    - ES6 이후 ( 계산된 프로퍼티 사용 )
        ```jsx
        const PROPERTY_NAME = "p1";
        function computePropertyName() {
            return "p" + 2;
        }

        let o = {
            [PROPERTY_NAME]: 1,
            [computePropertyName()]: 2,
        };
        ```

### 6.10.3 프로퍼티 이름인 심벌

1. 계산된 프로퍼티 문법을 통해 가능해진, 아주 중요한 객체 리터럴 기능이 있다.

    - ES6 이후에는 프로퍼티 이름에 문자열이나 심벌을 쓸 수 있다.
    - 심벌을 변수나 상수에 할당하면 계산된 프로퍼티 문법을 통해 그 심벌을 프로퍼티 이름으로 쓸 수 있다.

    ```jsx
    const extension = Symbol("my extension symbol");

    let o = {
        [extension]: {
            /*이 객체에 확장 데이터를 저장한다. */
        },
    };

    o[extension].x = 0; // o의 다른 프로퍼티와 충돌하지 않는다.
    ```

    - 심벌은 불투명한 값이다.
        - 심벌은 프로퍼티 이름 이외에 다른 용도로 쓸 수 없다.
        - 하지만 심벌은 다른 어떤 심벌과도 같지 않으므로 고유한 프로퍼티 이름을 만들 때 좋다.

1. `Symbol()`
    - 심벌은 객체가 아니라 기본 값으로, `Symbol()` 은 `new`와 함께 호출되는 생성자 함수가 아니다.
    - `Symbol()` 이 반환하는 값은 다른 어떰 심벌과도, 다른 어떤 값과도 같지 않다.
    - `Symbol()` 에 문자열을 전달할 수 있는데, 이 문자열은 심벌을 문자열로 변환할 때 사용된다.
        - 하지만 이 기능은 디버깅에만 도움이 된다.
        - 같은 문자열을 인자로 삼아 심벌을 생성해도 그들은 서로 다른 심벌이다.
    - 심벌의 목적은 보안이 아니라 자바스크립트 객체가 사용할 수 있는 안전한 확장 메커니즘을 정의하는 것이다.
        - 우리가 제어할 수 없는 서드 파티 코드에서 가져온 객체에 프로퍼티를 추가하고 싶지만, 추가한 프로퍼티가 이미 존재하는 프로퍼티와 충돌하지 않는다고 확신할 수 없을 때 프로퍼티 이름에 심벌을 사용하면 안전하다.
        - 이렇게 한다면 서드 파티 코드에서 여러분이 사용한 심벌 프로퍼티가 수정 될 일이 없다.
        - 물론 서드 파티 코드에서 `Object.getOwnPropertySymbols()` 를 사용해 우리가 추가한 심벌을 확인한다면 수정하거나 삭제할 수 있다.
            - 이게 보안 메커니즘에 사용할 수 없는 이유이다.

### 6.10.4 분해 연산자

1. ES2018 이후에는 객체 리터럴 안에서 분해 연산자 …를 사용해 기존 객체의 프로퍼티를 새 객체에 복사 할 수 있다.

    ```jsx
    let position = { x: 0, y: 0 };
    let dimensions = { width: 100, height: 75 };
    let rect = { ...position, ...dimensions };
    rect.x + rect.y + rect.width + rect.height; // => 175
    ```

    - `position`과 `dimensions` 객체의 프로퍼티는 `rect` 객체 안으로 ‘분해’되어, 마치 그 안에 문자 그대로 작성됐던 것처럼 포함된다.
    - 이 … 문법은 보통 분해 연산자라고 부르지만, 진정한 자바스크립트 연산자라고 볼 수는 없다.
        - 이것은 객체 리터럴 안에서만 사용할 수 있는 특별 문법이다.
        - 자바스크립트에선 점 세개를 다른 목적으로 사용하는 경우도 있지만, 객체를 다른 객체에 분산하는 용도로 사용하는 것은 객체 리터럴이 유일하다.

1. 분해되는 객체와 프로퍼티를 받는 객체 둘 다 같은 이름의 프로퍼티를 갖는다면 해당 프로퍼티의 값은 마지막에 오는 값이 된다.

    ```jsx
    let o = { x: 1 };
    let p = { x: 0, ...o };
    p.x; // 1
    let q = { ...o, x: 2 };
    q.x; // 2
    ```

1. 분해 연산자는 자체 프로퍼티만 분해할 뿐 상속된 프로퍼티에는 적용되지 않는다.

    ```jsx
    let o = Object.create({ x: 1 });
    let p = { ...o };
    o.x; // undefined
    ```

1. 분해 연산자는 코드로 보면 그저 점 세개일 뿐이지만, 자바스크립트 인터프리터가 이 때문에 상당히 많은 일을 하게 될 수도 있다.
    - 객체의 프로퍼티가 `n`개가 있으면 이 프로퍼티를 다른 객체로 분해하는 작업은 `O(n)` 작업일 것이다.
    - 따라서 …를 루프나 재귀 함수에 넣어 데이터를 큰 객체 하나에 누산한다면 n이 커질수록 비효율적인 `O(p²)` 알고리즘을 쓰게 되는 것이다.

### 6.10.5 단축 메서드

1. 객체 프로퍼티로 정의된 함수를 메서드라 부른다.

    - ES6 전에는 다른 프로퍼티를 정의할 때 처럼 객체 리터럴 안에 함수 정의 표현식을 써서 메서드를 정의했다.
        ```jsx
        let square = {
            area: function () {
                return this.side * this.side;
            },
            side: 10,
        };
        square.area(); // 100
        ```
    - ES6에서는 객체 리터럴 문법에서 `function` 키워드와 콜론을 생략할 수 있다.
        ```jsx
        let square = {
            area() {
                return this.side * this.side;
            },
            side: 10,
        };
        square.area(); // 100
        ```

    1. 이 단축 문법을 사용해 메서드를 작성할 때 프로퍼티 이름에는 객체 리터럴 안에 쓸 수 있다면 무엇이든 쓸 수 있다.
        - 일반적인 자바스크립트 식별자 외에도 문자열 리터럴, 계산된 프로퍼티 이름, 심벌 역시 사용할 수 있다.
            - 메서드 이름에 심벌을 사용?
                - 객체를 for/of 루프에서 사용할 수 있도록 이터러블로 만들려면 반드시 심벌 이름 `Symbol.iterator`를 사용해 메서드를 정의해야 한다.

    ### 6.10.6 프로퍼티 게터와 세터

    1. 자바스크립트는 접근자 메서드 게터(`getter`)와 세터(`setter`)를 작는 접근자 프로퍼티(`accessor property`) 역시 지원한다.

        - 프로그램이 접근자 프로퍼티의 값을 검색하면 자바스크립트는 인자 없이 게터 메서드를 호출한다.
            - 이 메서드의 반환 값이 프로퍼티 접근 표현식의 값이다.
        - 프로그램에서 접근자 프로퍼티의 값을 설정하려 하면 자바스크립트는 세터 메서드를 호출하고 할당 표현식의 오른쪽 값을 인자로 전달한다.
            - 이 메서드가 프로퍼티 값 ‘세팅’을 담당한다.
            - 세터 메서드의 반환 값은 무시한다.

    1. 프로퍼티에 게터와 세터 메서드가 모두 있으면 해당 프로퍼티는 읽기와 쓰기가 모두 가능한 프로퍼티 이다.

        - 게터 메서드 하나만 있다면 읽기 전용 프로퍼티이다.
        - 세터 메서드 하나만 있다면 쓰기 전용 프로퍼티이며 (데이터 프로퍼티에서는 불가능), 값을 읽으려 할하면 항상 `undefined`로 평가된다.

    1. 접근자 프로퍼티는 객체 리터럴 문법의 확장으로 정의할 수 있다.

        ```jsx
        let o = {
            // 일반적인 데이터 프로퍼티
            dataProp: value,

            // 함수의 쌍으로 정의된 접근자 프로퍼티
            get accessorProp() {
                return this.dataProp;
            },
            set accessorProp(value) {
                this.dataProp = value;
            },
        };
        ```

        - 접근자 프로퍼티는 한 개 혹은 두 개의 메서드 형태로 정의되며 그 이름은 프로퍼티 이름과 같다.
            - 계산된 프로퍼티 이름 역시 사용 가능하다.

    1. 접근자 프로퍼티는 데이터 프로퍼티와 마찬가지로 상속된다.

        ```jsx
        let p = {
            // x와 y는 일반적인 데이터 프로퍼티이다.
            x: 1.0,
            y: 1.0,

            get r() {
                return Math.hypot(this.x, this.y);
            },
            set r(newValue) {
                let oldValue = Math.hypot(this.x, this.y);
                let ratio = newValue / oldValue;
                this.x *= ratio;
                this.y *= ratio;
            },

            get theta() {
                return Math.atan2(this.y, this.x);
            },
        };

        let q = Object.create(o);
        (q.x = 3), (q.y = 4);
        q.r; // 5
        q.theta; // Math.atan2(4,3)
        ```
