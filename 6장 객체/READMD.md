## 6.1 객체 소개

1. 객체는 복합된 값이다.

    - 객체는 여러 가지 값(기본 값이나 다른 객체)을 모아서 이름을 통해 값을 저장하고 가져올 수 있게한다.
    - 객체는 프로퍼티의 순서 없는 집합이며 각 프로퍼티에는 이름과 값이 있다.
        - 프로퍼티의 이름은 보통 문자열이다.
    - 하지만, 객체는 단순히 문자열과 값을 연결한 것이 아니다.
        - 자바스크립트 객체는 자신만의 프로퍼티를 가지는 것 외에도, ‘프로토타입’으로 불리는 다른 객체에서 프로퍼티를 상속하기도 한다.
        - 객체의 메서드는 일반적으로 상속된 프로퍼티이며 이 ‘프로토타입 상속’이 자바스크립트의 중요한 기능이다.

1. 자바스크립트 객체는 동적이기 때문에 일반적으로 프로퍼티를 추가하거나 삭제할 수 있다.

    - 대신 정적인 객체를 흉내 낼 수도 있고 정적 타입을 사용하는 언어의 구조 역시 사용할 수 있다.

1. 객체는 가변이며 값이 아닌 참조로 조작한다.

    ```jsx
    let x = { a: 1 };

    let y = x;
    ```

    - 변수 y는 변수 x의 객체 사본이 아니라 같은 객체를 참조한다.
        - 변수 y를 통해 객체를 수정하면 그 결과는 변수 x에도 똑같이 적용된다.

1. 객체를 통해 하는 일에는 생성, 검색, 삭제, 테스트, 프로퍼티 열거로 나눌 수 있다.

1. 프로퍼티에는 이름과 값이 있다.

    - 프로퍼티 이름에는 빈 문자열과 심벌을 포함해 어떤 문자열이든 쓸 수 있지만, 같은 이름의 프로퍼티는 존재할 수 없다.
    - 값은 타입을 가리지 않는 자바스크립트 값이며, `getter`와 `setter`, 또는 둘 다가 될 수 있다.

1. 객체에서 직접 정의한 프로퍼티와 프로토타입 객체에서 상속한 프로퍼티를 구별하는 것이 중요할 때도 있다.
    - 상속되지 않는 프로퍼티를 자체 프로퍼티(`own property`)라고 부른다.
    - 모든 프로퍼티에는 이름과 값 외에도 세가지 프로퍼티 속성이 있다.
        - 쓰기가능 속성
            - 프로퍼티에 값을 설정할 수 있는지 없는지를 나타낸다.
        - 열거가능 속성
            - `for/in` 루프에 프로퍼티 이름을 반환할지 안 할지를 나타낸다.
        - 변경가능 속성
            - 프로퍼티를 삭제할 수 있는지 없는지, 속성을 바꿀 수 있는지 없는지를 나타낸다.
    - 자바스크립트의 내장 객체의 프로퍼티 중 상당수는 읽기 전용이거나 열거 불가, 변경 불가이다.
    - 자체 프로퍼티는 기본적으로 쓰기 가능, 열거 가능, 변경 가능이다.

## 6.2 객체 생성

1. 객체를 생성할 때는 객체 리터럴, `new` 키워드, `Object.create()` 함수를 사용한다.

### 6.2.1 객체 리터럴

1. 객체를 생성하는 가장 쉬운 방법이다.

    ```jsx
    const x = { a: 1, b: 2 };
    ```

    - 프로퍼티 이름은 자바스크립트 식별자 또는 문자열 리터럴이고, 빈 문자열도 허용한다.
    - 프로퍼티 값은 자바스크립트 표현식이면 무엇이든 가능하다.

    ```jsx
    let empty = {};
    let point = { x: 0, y: 0 };
    let p2 = { x: point.x, y: point.y + 1 };
    let book = {
        "main title": "JavaScript",
        "sub-title": "The Definitive Guide",
        for: "all audiences", // for는 예약어지만 사용 가능
        author: {
            firstname: "David",
            surname: "~~~~",
        },
    };
    ```

1. 객체 리터럴을 평가할 때마다 새 객체가 만들어진다.
    - 각 프로퍼티의 값 역시 리터럴을 평가할 때마다 평가된다.
    - 따라서, 객체 리터럴 자체가 바뀌지 않더라도 반복적으로 호출되는 함수나 루프 바디 안에 있다면 새 객체를 여러 개 만들 수 있으며, 이 객체들의 프로퍼티 값 역시 매번 달라질 수 있다.

### 6.2.2 new

1. `new` 연산자
    - 새 객체를 생성하고 초기화한다.
    - `new` 키워드 뒤에는 반드시 함수 호출이 있어야 한다.
    - 이런 형태로 사용하는 함수를 생성자라고 한다.
        - 자바스크립트 내장 타입에도 생성자가 있다.
        ```jsx
        let o = new Object(); // 빈 객체를 만든다. {}와 같다.
        let a = new Array(); // 빈 배열을 만든다. []와 같다.
        let d = new Date(); // 현재 시간을 나타내는 Date 객체를 만든다.
        let r = new Map(); // 키와 값을 연결하는 Map 객체를 만든다.
        ```

### 6.2.3 프로토 타입

1. 자바스크립트 객체 거의 대부분은 자신과 연결된 두 번째 객체를 갖는다.
    - 여기서 두 번째 객체를 프로토타입이라 부른다.
    - 첫 번째 객체는 프로토타입에서 프로퍼티를 상속한다.
2. 객체의 생성 방법 별 프로토타입

    - 객체 리터럴을 사용해 생성한 객체
        - 모두 같은 프로토타입 객체를 갖는다.
        - 이 프로토타입 객체는 `Object.prototype` 이라는 코드로 참조할 수 있다.
    - `new` 키워드와 생성자를 사용해 만든 객체
        - 생성자 함수의 `prototype` 프로퍼티 값을 자신의 프로토타입으로 사용한다.
            - `new Object()`로 생성한 객체의 프로토타입은 `{}` 로 생성한 객체와 마찬가지로 `Object.prototype`이다.
            - `new Array()`를 사용해 생성된 객체의 프로토타입은 `Array.prototype`이다.
            - `new Date()`를 사용해 생성된 객체의 프로토타입은 `Date.prototype`이다.

3. 거의 모든 객체에 프로토타입이 있지만, `prototype` 프로퍼티가 있는 객체는 비교적 적다.
    - `prototype` 프로퍼티를 갖는 객체가 다른 객체의 프로토타입을 정의한다.
    - `Object.prototype`은 프로토타입이 없는 드문 객체 중 하나다.
        - 이 객체는 어떤 프로퍼티도 상속하지 않는다.
    - 다른 프로토타입 객체는 일반적인 객체이며 역시 프로토타입이 있다.
    - 내장 생성자 대부분에 (대부분의 사용자 정의 생성자 역시) `Object.prototype`에서 프로퍼티를 상속하므로 `new Date()`로 생성한 `Date` 객체는 `Date.prototype`와 `Object.prototype` 양쪽에서 프로퍼티를 상속합니다.
        - 이렇게 이어지는 프로토타입 객체 사이의 연결을 프로토타입 체인이라 부른다.

### 6.2.4 Object.create()

1. `Object.create()`

    - `Object.create()`는 첫 번째 인자를 프로토타입 삼아 새 객체를 생성한다.

    ```jsx
    let o = Object.create({ x: 1, y: 2 }); // o1은 x와 y프로퍼티를 상속한다.
    ```

    - 인자로 `null`을 전달해 프로토타입이 없는 객체를 생성할 수도 있지만, 이렇게 생성된 객체는 아무것도 상속하지 않으며 기본 메서드조차 없다.
    - `{}`나 `new Object()`가 반환하는 것처럼 일반적인 빈 객체를 만들고 싶을 때는 `Object.prototype`을 전달한다.

    ```jsx
    let o = Object.create(Object.prototype);
    ```

1. `Object.create()`을 사용하는 목적
    - 서드 파티 라이브러리에서 객체를 변경하는 사고를 막는 것!!
        - 객체를 라이브러리 함수에 전달하지 않고 원래 객체를 상속하는 객체를 전달하면, 그 함수는 아무 문제 없이 상속된 값을 읽을 수 있다.
        - 라이브러리에서 부주의하게 프로퍼티 값을 바꾸더라도 원래 객체에는 영향이 없다.

## 6.3 프로퍼티 검색과 설정

1. 프로퍼티 값에 접근 할 때는 점(`.`)이나 대괄호(`[]`) 연산자를 사용한다.

    - 점 연산자를 사용한다면 오른쪽은 반드시 프로퍼티 이름인 단순한 식별자여야 한다.
    - 대괄호 연산자를 사용한다면 그 안에 있는 값은 원하는 프로퍼티 이름인 문자열로 평가되는 표현식이어야 한다.

1. 프로퍼티를 생성하거나 설정할 때도 마찬가지로 점(`.`)이나 대괄호(`[]`) 연산자를 사용하고, 이들을 할당 표현식 왼쪽에 써야 한다.

### 6.3.1 연관 배열인 객체

1. `object[”property”]`

    - 마치 숫자가 아닌 문자열로 인덱스된 배열에 접근하는 것처럼 대괄호 안에 문자열을 사용했다.
        - 문자열을 인덱스로 사용하는 배열을 연관 배열 이라고 부른다.

1. 프로퍼티 검색 중 대괄호 연산자
    - C,C++,자바 등 타입이 고정된 언어에서는 객체의 프로퍼티 개수가 고정되어 있으며, 프로퍼티 이름 역시 반드시 미리 정의되어 있어야 한다.
        - 하지만 자바스크립트는 타입을 엄격하게 고정하지 않으므로 이런 규칙이 없다.
    - 점 연산자를 사용해 객체프로퍼티에 접근할 때 프로퍼티 이름은 식별자로 표현된다.
        - 식별자는 반드시 문자 그대로 프로그램에 입력해야한다.
        - 식별자는 데이터 타입이 아니므로 프로그램에서 조작할 수 없다.
    - 대괄호 연산자는 객체 프로퍼티에 접근할 때는 프로퍼티 이름을 문자열로 표현한다.
        - 문자열은 자바스크립트 데이터 타입이므로, 프로그램이 실행되는 동안 새로 생성할 수도 있고 조작할 수도 있다.
        ```jsx
        let addr = "";
        for (let i = 0; i < 4; i++) {
            addr += customer[`address${i}`] + "\n";
        }
        ```
        - 대괄호 연산자는 동적이고 런타임에 바꿀 수 있는 문자열 값을 사용한다.
        ```jsx
        function addstock(portfolio, stockname, shares) {
            portfolio[stockname] = shares;
        }
        ```

### 6.3.2 상속

1. 자바스크립트 객체에는 자체 프로퍼티도 있고, 프로토타입 객체에서 상속하는 프로퍼티도 있다.

1. 예시) 객체 `o`의 `x`프로퍼티를 가져온다고 가정!

    - `o`에 `x`라는 자체 프로퍼티가 없다면?
        - `o`의 프로토타입 객체에서 `x`프로퍼티를 검색한다.
    - 프로토타입 객체에도 자체프로퍼티 `x`는 없지만 프로토타입이 있다면?
        - 프로토타입의 프로토타입에서 해당 프로퍼티를 검색한다.
    - `x`프로퍼티를 찾거나, 프로토타입이 `null`인 객체에 도달할 때 까지 검색을 계속한다.
    - 객체의 `prototype` 속성은 자신이 어디에서 프로퍼티를 상속했는지 나타내는 체인을 형성한다.

    ```jsx
    let o = {}; // o는 Object.prototype에서 객체 메서드를 상속한다.
    o.x = 1; // 자체 프로퍼티 x 생성
    let p = Object.create(o); // p는 o와 Object.prototype에서 프로퍼티를 상속한다.
    p.y = 2; // 자체 프로퍼티 y 생성
    let q = Object.create(p); // q는 p와 o와 Object.prototype에서 프로퍼티를 상속한다.
    q.z = 3; // 자체 프로퍼티 z 생성
    let f = q.toString(); // toString()은  Object.prototype에서 상속함.
    q.x + q.y; // => 3 x와 y는 o와 p에서 상속함.
    ```

1. 예시) 객체 `o`의 `x`프로퍼티에 값을 할당한다고 가정!

    - `o`에 이미 자체 (상속되지 않은) `x`프로퍼티가 있다면?
        - 그 할당은 기존 프로퍼티의 값을 바꾼다.
    - 그렇지 않다면?
        - 객체 `o`에 `x`프로퍼티를 새로 만들고 거기에 할당한다.
    - `o`에 상속된 프로퍼티 `x`가 있었다면?
        - 상속된 프로퍼티는 이제 새로 생성된 자체 프로퍼티에 ‘가려진다.’
    - 프로퍼티 할당은 프로토타입 체인을 검색해 할당이 허용되는지 확인한다.
        - `o`가 읽기 전용인 `x`프로퍼티를 상속한다면 할당은 허용되지 않는다.
        - 하지만 할당이 허용된다면 항상 원래 객체의 프로퍼티를 생성하거나 설정할 뿐, 프로토타입 체인에 존재하는 객체는 절대 수정하지 않는다.
        - 프로퍼티를 검색할 때는 상속을 감안하지만 설정할 때는 그렇지 않으므로 상속된 프로퍼티도 덮어 쓸 수 있다.

1. 프로퍼티 할당은 실패하거나, 아니면 원래 객체에 프로퍼티를 생성 또는 설정한다는 규칙에는 한가지 예외가 있다.
    - `o`가 `x`프로퍼티를 상속하고 그 프로퍼티가 세터 메서드가 있는 접근자 프로퍼티라면?
        - `o`에 `x`프로퍼티를 새로 만드는 대신 세터 메서드를 호출한다.
    - 하지만, 세터 메서드는 객체 `o`에 호출되는 것이지 해당 프로퍼티를 정의한 프로토타입 객체에 호출되는 것이 아니므로, 세터 메서드가 프로퍼티를 변경하더라도 `o`에 변화가 있을 뿐 프로토타입 체인은 변하지 않는다.

### 6.3.3 프로퍼티 접근 에러

1. 접근 에러

    - 존재하지 않는 프로퍼티를 검색하는 것은 에러가 아니다
        - `o`의 자체 프로퍼티나 상속된 프로퍼티에서 `x`프로퍼티를 찾지 못한다면 `undefined`로 평가된다.
        ```jsx
        book.subtitle; // => undefined: 프로퍼티가 존재하지 않습니다.
        ```
    - 존재하지 않는 객체의 프로퍼티를 검색하려 하는 것은 에러이다.
        - `null`과 `undefined`에는 프로퍼티가 없고 이런 값에서 프로퍼티를 검색하려 하는 것은 에러다.
        ```jsx
        book.subtitle.length; // TypeError: undefined에는 length 프로퍼티가 없습니다.
        ```
    - `null`이나 `undefined`의 프로퍼티를 설정하려 해도 TypeError가 일어난다.

1. 프로퍼티 할당이 실패할때 ( 객체 `o`에 프로퍼티 `p`를 설정하려는 시도 )
    - `o`에 자체 프로퍼티 `p`가 있고 읽기 전용일 때
        - 읽기 전용 프로퍼티의 값은 바꿀 수 없다.
    - `o`에 상속된 프로퍼티 `p`가 있고 읽기 전용일 때
        - 상속된 읽기 전용 프로퍼티를 같은 이름의 자체 프로퍼티로 가릴 수 없다.
    - `o`에 자체 프로퍼티 `p`가 없으며 세터 메서드로 프로퍼티 `p`를 상속하지 않고 `o`의 확장 가능 속성이 `false`일 때
        - `p`는 `o`에 존재하지 않고 호출할 세터 메서드도 없으므로 `p`를 `o`에 추가해야 하지만, `o`는 확장 불가이므로 새 프로퍼티를 설정할 수 없다.

## 6.4 프로퍼티 삭제

1. `delete` 연산자는 객체에서 프로퍼티를 삭제한다.

    - 피연산자는 프로퍼티 접근 표현식이여야 한다.
    - 값을 삭제하는 것이 아니라 프로퍼티 자체를 삭제한다.

1. `delete` 연산자는 자체 프로퍼티만 삭제할 뿐 상속된 프로퍼티는 삭제하지 않는다.

    - 상속된 프로퍼티를 삭제하려면 반드시 해당 프로퍼티를 정의한 프로토타입 객체에서 삭제해야 한다.
    - 이렇게 하면 해당 프로토타입을 상속한 객체 전체에 영향을 미친다.

1. `delete` 표현식은 삭제에 성공했을 때, 또는 존재하지 않는 프로퍼티 삭제를 시도하는 등 효과가 없었을 때 `true`로 평가된다.

    - `delete` 는 프로퍼티 접근 표현식이 아닌 표현식을 사용했을 때도 (아무 의미 없지만) `true`로 평가된다.

1. `delete` 는 변경 가능 속성이 `false`인 프로퍼티는 제거하지 않는다.
    - 내장 객체의 일부 프로퍼티, 변수 선언이나 함수 선언으로 생성된 전역 객체의 프로퍼티는 변경 불가이다.
    - 스트릭트 모드에서는 변경 불가인 프로퍼티를 삭제하려 하면 `TypeError`가 일어난다.
    - 일반 모드에서는 에러가 일어나지않고 `false`로 평가된다.

## 6.5 프로퍼티 테스트

1. 자바스크립트 객체는 프로퍼티 집합으로 볼 수 있으며, 주어진 이름을 가진 프로퍼티가 객체에 존재하는지 확인해야 할 때가 있다.

    - 이 경우 `in` 연산자, `hasOwnProperty()`, `propertyIsEnumerable()` 메서드를 사용하거나 그냥 프로퍼티를 검색하면 된다.

1. `in` 연산자는 왼쪽에 프로퍼티 이름, 오른쪽에 객체를 예상한다.

    - 객체에 그런 이름을 가진 자체 프로퍼티나 상속된 프로퍼티가 있다면 `true`를 반환한다.

    ```jsx
    let o = { x: 1 };

    "x" in o; // true
    "y" in o; // false
    "toString" in o; // true
    ```

1. `hasOwnProperty()` 메서드는 객체에 주어진 이름을 가진 자체 프로퍼티가 있는지 테스트 한다.

    - 상속된 프로퍼티에는 `false`를 반환한다.

    ```jsx
    let o = { x: 1 };

    o.hasOwnProperty("x"); // true
    o.hasOwnProperty("y"); // false
    o.hasOwnProperty("toString"); // false
    ```

1. `propertyIsEnumerable()` 은 `hasOwnProperty()` 를 더 제한한 버전이다.

    - 이 메서드는 지정된 프로퍼티가 자체 프로퍼티이며 열거 가능 속성이 true일 때만 true를 반환한다.
    - 일부 내장 프로퍼티는 열거 불가이다.
    - 일반적인 자바스크립트 코드로 생성한 프로퍼티는 모두 열거 가능이다.

    ```jsx
    let o = { x: 1 };

    o.propertyIsEnumerable("x"); // true
    o.propertyIsEnumerable("toString"); // false
    Object.prototype.propertyIsEnumerable("toString"); // false
    ```

1. `in` 연산자 대신 그냥 프로퍼티를 검색하고 `!==` 를 써서 `undefined`가 아님을 확인해도 된다.

    ```jsx
    let o = { x: 1 };

    o.x !== undefined; // true
    o.y !== undefined; // false
    o.toString !== undefined; // true
    ```

1. `in`은 존재하지 않는 프로퍼티와 존재하지만 값이 `undefined` 인 프로퍼티를 구분할 수 있다.

    ```jsx
    let o = { x: undefined };

    o.x !== undefined; // false
    o.y !== undefined; // false
    x in "o"; // true
    y in "o"; // false
    delete o.x;
    x in "o"; // false
    ```

## 6.6 프로퍼티 열거

1. 객체의 프로퍼티 전체를 순회해야 할 때!

    - `for/in` 루프는 지정된 객체의 상속 여부를 구분하지 않고 열거 가능 프로퍼티마다 그 이름을 루프 변수에 할당하면서 루프 바디를 실행한다.

        - 객체가 상속하는 내장 메서드는 열거 불가이지만, 우리가 추가한 프로퍼티는 기본적으로 열거 가능이다.

        ```jsx
        let o = { x: 1, y: 2, z: 3 };

        o.propertyIsEnumerable("toString"); // false
        for (let p in o) {
            console.log(p);
        }
        ```

        - `for/in` 에서 상속된 프로퍼티가 열거되는 것을 막을 때는 명시적으로 체크해야한다.

        ```jsx
        for (let p in o) {
            if (!o.hasOwnProperty(p)) continue; // 상속된 프로퍼티는 건너뛴다.
        }

        for (let p in o) {
            if (typeof o[p] === "function") continue; // 메서드는 건너뛴다.
        }
        ```

    - `for/in` 루프를 사용하는 것보다 객체의 프로퍼티 이름을 배열에 저장해서 `for/of` 루프를 사용하는 것이 더 쉽다.
        - `Object.keys()` 는 객체의 열거 가능한 자체 프로퍼티 이름을 배열로 반환한다. 이 메서드는 열거 불가 프로퍼티, 상속된 프로퍼티, 이름이 심벌인 프로퍼티는 내보내지 않는다.
        - `Object.getOwnPropertyNames()` 는 `Object.keys()` 와 비슷하지만, 이름이 문자열이기만 하면 열거 불가인 자체 프로퍼티 이름도 배열로 반환한다.
        - `Object.getOwnPropertySymbols()` 는 열거 가능 여부를 따지지 않고 이름이 심벌인 자체 프로퍼티를 배열로 반환한다.
        - `Reflect.ownKeys()` 열거 가능 여부를 따지지 않고, 문자열인지 심벌인지 구분 하지 않고 자체 프로퍼티 이름은 전부 배열로 반환한다.

    ### 6.6.1 프로퍼티 열거 순서

    1. 객체의 자체 프로퍼티를 열거하는 순서는 ES6에서 공식적으로 정의했다.

        - `Object.keys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbols(), Reflect.ownKeys(), JSON.stringify()`등 관련 메서드는 다음 순서에 따라 프로퍼티를 열거한다.
        - 또한 열거 불가 프로퍼티를 반환하는지, 프로퍼티 이름이 문자열인지 심벌인지에 따른 제한이 함께 적용된다.
            1. 이름이 음이 아닌 정수인 문자열 프로퍼티가 첫 번째로 나열되며 작은 수에서 큰 수 순으로 열거된다. 따라서 배열 및 배열 비슷한 객체의 프로퍼티도 순서대로 열거된다.
            2. 배열 인덱스와 비슷한 프로퍼티를 모두 열거한 다음에는 음수나 부동 소수점 숫자처럼 보이는 프로퍼티를 포함해 이름이 문자열인 프로퍼티를 열거한다. 이 프로퍼티는 객체에 추가된 순서대로 열거된다. 객체 리터럴로 정의된 프로퍼티는 리터럴에 쓰인 순서를 따른다.
            3. 마지막으로, 이름이 심벌인 프로퍼티를 객체에 추가된 순서대로 열거한다.

    1. `for/in` 루프의 열거 순서는 이 열거 함수만큼 정확하게 정의되어 있지는 않지만, 대부분의 실행 환경에서 자체 프로퍼티를 위에 설명한 순서대로 열거하고 프로토타입 체인을 따라 올라가면서 각 프로토타입 객체에 대해 열거 가능한 프로퍼티를 같은 순서로 열거한다.
        - 하지만 같은 이름의 프로퍼티가 이미 열거됐다면 열거하지 않으며, 이미 고려된 프로퍼티 중 같은 이름의 열거 불가 프로퍼티가 있었다면 열거하지 않는다.
