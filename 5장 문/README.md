## 5.1 표현문

1. 할당이나 함수 호출처럼 부수 효과가 있는 표현식

    - 할당문은 표현문의 주요 카테고리 중 하나이다.

    ```jsx
    greeting = "Hello " + name;
    i *= 3;
    ```

    - 증가와 감소 연산자 `++`와 `--` 도 할당문과 관련이 있다.
        - 이들은 할당을 수행한 것처럼 변수의 값을 바꾸는 부수 효과가 있다.
        ```jsx
        counter++;
        ```
    - `delete` 연산자에는 객체 프로퍼티를 삭제하는 중요한 부수 효과가 있다.

    ```jsx
    delete o.x;
    ```

    - 함수 호출도 표현문의 주요 카테고리 중 하나이다.
        - 함수 호출은 표현식이지만 프로그램의 상태나 호스트 환경에 영향을 미치는 부수효과가 있다.

## 5.2 복합문과 빈 문

1. 문 블록

    - 문 블록은 문 여러 개를 묶어 복합문으로 만든다.
        - 그저 문 여러개를 중괄호로 묶은 것
    - 복합문은 문이 하나인 것 처럼 동작한다.

    ```jsx
    {
        x = Math.PI;
        cx = Math.cos(x);
    }
    ```

1. 자바스크립트 문법은 공식적으로 단일 하위 문을 허용한다.
    - 문 블록을 사용하면 허용되는 하위 문 하나에 문 여러개를 넣을 수 있다.

## 5.3 조건문

1. 지정된 표현식의 값에 따라 다른 문을 실행하기도, 실행하지 않기도 한다.
    - 분기문이라고도 함.

### 5.3.1 if

1. `if` 문은 자바스크립트가 조건에 따라 문을 실행할 수 있게 하는 기본적인 제어문이다.

1. `if` 문의 형태

    ```jsx
    if (expression) {
        statement1;
    } else {
        statement2;
    }
    ```

    - `expression`을 평가하고
        - 결괏값이 `true` 같은 값이면 `statement1` 문을 실행한다.
        - 결괏값이 `false` 같은 값이면 `statement2` 문을 실행한다.

1. 문 블록
    - 문이 하나 일때는 문 블록을 사용하지 않을 수 있지만 이해하고, 관리하고, 디버그하기 쉽게 하려면 문 블록을 작성해주자.
    - 예기치 못한 결과값이 나올수 있다.

### 5.3.2 else if

1. `if/else` 문은 표현식을 평가하고 그 결과에 따라 두 코드 중 하나를 실행한다.
    - 하지만 선택지가 여럿이라면?
    - `else if` 문을 사용하자.
2. 엄밀히 말해 `else if`는 자바스크립트 문이 아니다.
    - `if/else` 문을 반복해 사용해야 할 때 흔히 쓰는 관용적 표현이다.

### 5.3.3 switch

1. 모든 분기점이 같은 표현식의 값에 좌우된다면 `else if` 가 최선의 선택은 아니다.

1. `switch` 문의 형태

    ```jsx
    switch (expression) {
        case 1:
            // 코드 블록 #1을 실핸한다.
            break;
        case 2:
            // 코드 블록 #2을 실핸한다.
            break;
        case 3:
            // 코드 블록 #3을 실핸한다.
            break;
        default:
            // 코드 블록 #4을 실핸한다.
            break;
    }
    ```

    - `switch` 문이 실행되면 먼저 `expression`의 값을 계산한 후, `case`의 라벨의 표현식 중에서 `expression`과 같은 값으로 평가되는 것을 찾는다.
        - 이때 `===` 연산자를 기준으로 판단한다.
    - 일치하는 것을 찾으면 해당 `case`의 코드 블록을 실행한다.
    - `case`를 찾지 못하면 `default:` 라벨을 찾는다.
    - `default:` 라벨 조차 없으면 `switch`문은 코드 블록 전체를 건너 뛴다.

1. `break` 문
    - 인터프리터가 `switch` 문의 끝으로 빠져나가서 이어지는 문을 실행하게 하는 명령이다.
    - `switch` 문의 `case` 절은 코드의 출발점을 지정할 뿐, 어디서 끝나는지 지정하지 않는다.
        - `break` 문이 없다면 `switch`문은 `expression` 의 값과 일치하는 `case` 라벨을 찾아 코드를 실행한 다음, 블록의 끝에 다다를 때까지 실행을 계속한다.
    - `break`문 대신 `return`문을 써도 된다.
1. `switch` 문을 실행할 때마다 `case` 표현식 전체가 평가되는 것은 아니므로 `case` 표현식에는 함수 호출이나 할당처럼 부수 효과가 있는 것은 피해야한다.
    - 가장 안전한 방법은 `case` 표현식에 일정한 표현식만 쓰는 것!

## 5.4 반복문

1. 반복문은 경로를 자기 자신 쪽으로 구부려 코드 일부를 반복하는 문이며 루프라고 하기도 한다.

    - 루프는 모두 배열 요소를 순회할 때 쓸 수있다.

1. 자바스크립트의 반복문 종류
    - `while`
    - `do/while`
    - `for`
    - `for of ( 변형인 for/await )`
    - `for in`

### 5.4.1 while

1. `while`문은 자바스크립트의 기본 루프이다.

1. `while`문의 형태

    ```jsx
    while (expression) {
        statement;
    }
    ```

    - 인터프리터는 먼저 `expression`를 평가한다.
        - 값이 `false` 같은 값이면 인터프리터는 루프 바디를 건너 뛰고 다음 문으로 이동한다.
        - 값이 `true` 같은 값이면 인터프리터는 `statement`를 실행하고, 루프 맨 위로 올라가 `expression`를 평가하길 반복한다.
    - 쉽게 말하면, 인터프리터는 `expression`이 true 같은 값인 동안 `statement`를 반복저으로 실행한다.

### 5.4.2 do/while

1. `do/while` 루프는 `while` 루프와 비슷하지만 루프 표현식이 루프 맨 위가 아니라 맨 아래에서 평가된다는 점이 다르다.

    - 따라서, 루프 바디는 항상 최소 한 번은 실행 된다.

1. `do/while`문의 형태

    ```jsx
    do {
        statement;
    } while (expression);
    ```

1. `do/while`문과 `while`문의 차이점
    - `do/while` 루프는 루프 시작을 알리는 `do` 키워드와 루프의 끝을 알리고 조건을 평가하는 `while` 키워드가 모두 있어야 한다.
    - `do/while` 루프는 반드시 항상 세미콜론으로 끝나야 한다.

### 5.4.3 for

1. for문은 널리 쓰이는 루프 패턴을 단순화 한것이다.

    - 루프 패턴
        - 대부분의 루프에는 어떤 형태로든 카운터 변수가 있다.
            - 이 변수는 루프 시작 전에 초기화되고 루프가 반복될 때마다 테스트 된다.
        - 마지막으로 루프 바디 끝에서 카운터 변수를 다시 테스트하기 직전에 증가시키거나 다른 방식으로 업데이트를한다.
    - 이런 루프에서 초기화, 테스트, 업데이트는 필수불가결한 동작이다.
    - for 문은 이 세 가지 동작을 표현식 하나로 묶고, 이들을 루프 문법에 명시적으로 포함한다.

1. for문의 형태

    ```jsx
    for (initalize; test; increment) {
        statement;
    }
    ```

    - `initalize, test, increment`는 세미콜론으로 구분하며 각각 루프 변수의 초기화, 테스트, 증가를 담당한다.
        - 콤마 연산자를 사용하여 여러 개의 초기화와 증가 표현식을 표현식 하나로 묶어 `for` 루프에 사용할 수 있다.

1. `while`문과의 비교

    ```jsx
    initalize;
    while (test) {
        statement;
        increment;
    }
    ```

1. 생략 가능
    - `for` 루프의 세 가지 표현식은 전부 생략할 수 있지만 세미클론은 필수이다.
        - 단 test 표현식을 생략하면 루프는 무한히 반복한다.

### 5.4.4 for of

1. `for of`는 ES6에서 정의한 새 반복문이다.

    - `for` 키워드를 사용하긴 하지만 일반적인 `for` 루프와는 완전히 다르다.
    - `for in` 이랑도 다르다.

1. `for of` 루프는 이터러블 객체에서 동작한다.
    - 이터러블 객체
        - 배열, 문자열, 세트, 맵
        - 이들은 `for of` 루프로 순회할 수 있는 일종의 연속체 또는 일련의 요소이다.
1. `for of` 예제

    ```jsx
    let data = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    let sum = 0;

    for (let element of data) {
        sum += element;
    }

    sum; // 45
    ```

    - `for` 키워드를 쓰고, 그 뒤에 이 루프가 하는 일을 괄호로 묶어서 표현했다.
        - 여기서 괄호 안에 는 변수 선언이 있고, `of` 키워드가 있고, 그 뒤에는 `data` 배열처럼 이터러블 객체로 평가되는 표현식이 있다.
    - 루프 바디는 `data` 배열의 각 요소에 대해 한 번씩 실행된다.
        - 루프 바디를 실행하기 전, 배열의 다음 요소가 `element` 변수에 할당된다.
    - 배열은 ‘동적으로’ 순회한다.
        - 즉 반복 중간에 배열 자체에 변화가 발생한다면 반복 결과가 바뀌기도 한다.

### for of와 객체

1. 객체는 기본적으로 이터러블이 아니다.

    - 일반적인 객체에 `for of`을 사용하려 하면 런타임에 `TypeError`가 일어난다.

1. 객체의 프로퍼티를 순회하고 싶다면 `for in`을 사용하거나 `Object.key()` 메서드에 for of를 사용하자.

1. 객체 프로퍼티의 키와 값이 모두 필요하다면 `Object.entries()`를 사용하자!

    - `Object.entries()`
        - 배열의 배열을 반환한다.
        - 그 내부 배열은 객체의 프로퍼티에 대응하는 키-값 쌍이다.

    ```jsx
    let o = {
        x: 1,
        y: 2,
        z: 3,
    };

    let paris = "";
    for (let [k, v] of Object.entries(o)) {
        paris += k + v;
    }
    paris; // x1y2z3
    ```

### for of와 문자열

1. ES6 이후에는 문자열을 문자 단위로 순회할 수 있다.
    - 문자열은 UTF-16 문자가 아니라 유니코드 코드 포인트로 순회한다.

### for of와 세트, 맵

1. ES6에 내장된 `Set`와 `Map`클래스는 이터러블이다.

1. `Set`

    - `Set`을 `for of`로 순회하면 루프 바디는 `Set`의 각 요소에 대해 한 번씩 실행된다.

    ```jsx
    let text = "Na na na na na na Betman!";
    let wordSet = new Set(text.split(" "));
    let unique = [];
    for (let word of wordSet) {
        unique.push(word);
    }
    unique; // ["Na", 'na', 'Betman!']
    ```

1. Map
    - `Map` 객체의 이터레이터는 키-값 쌍을 순회한다.
        - 반복할 때마다 이터레이터는 첫 번째 요소가 키, 두번째 요소가 키에 대응하는 값인 배열을 반환한다.
        ```jsx
        let m = new Map([[1, "one"]]);
        for (let [key, val] of m) {
            key; // 1
            val; // 'one'
        }
        ```

### for await를 사용한 비동기 순회

1. ES2018은 비동기 이터레이터라는 새로운 이터레이터를 도입하면서 `for await`를 도입했다.

### 5.4.5 for in

1. `for in` 루프는 `for of` 루프와 거의 비슷하다

    - `for of`는 `of` 다음에 이터러블 객체가 와야 하지만 `for in` 루프는 `in` 다음에 어떤 객체든 쓸 수 있다.

1. `for in`의 형태

    ```jsx
    for (variable in object) {
        statement;
    }
    ```

    - `variable`에는 일반적으로 변수 이름이 들어가지만 변수 선언이 될 수도 있고 할당 표현식에서 왼쪽에 올 수 있는 것은 무엇이든 가능하다.
    - `object`는 객체로 평가되는 표현식

1. 실행

    - 자바스크립트 인터프리터는 `for in` 문을 실행할 때 첫번째로 `object` 표현식을 평가한다.
        - 표현식이 `null`이나 `undefined`로 평가되면 인터프리터는 루프를 건너 뛰고 다음 문으로 이동한다.
        - 그렇지 않으면 인터프리터는 객체의 열거 가능한 프로퍼티 각각에 한 번씩 루프 바디를 실행한다.
    - 각 반복에 앞서 인터프리터는 `variable`를 표현식을 평가하고 그 변수에 프로퍼티 이름을 할당한다.

1. 주의점
    - `for in` 루프는 실제로 객체의 프로퍼티 전체를 열거하지 않는다.
        - 이름이 심벌인 프로퍼티는 열거하지 않는다.
        - 이름이 문자열인 프로퍼티 중에서도 열거 가능한 프로퍼티만 순회한다.
        - 자바스크립트에서 정의하는 내장 메서드는 열거 가능하지 않다.
    - 내가 직접 정의한 프로퍼티와 메서드는 기본적으로 열거 가능하다.
    - 열거 가능한 상속된 프로퍼티 역시 `for in` 루프의 순회 대상에 속한다.
        - 따라서, 모든 객체에서 상속하는 프로퍼티를 정의하고 `for in` 루프를 사용한다면 결과가 예상과 다를 수 있다.
            - 이 때문에 많은 프로그래머들은 `for in` 대신 `Object.keys()`와 `for of` 조합을 더 선호한다.
    - `for in` 루프의 바디에서 아직 열거되지 않은 프로퍼티를 삭제한다면 그 프로퍼티는 순회 대상에서 빠진다.
    - 루프 바디에서 객체의 새 프로퍼티를 정의한다면 그 프로퍼티는 순회 대상에 있을 수도 있고 없을 수 도 있다.
        - 자세한건 6장에서 설명

## 5.5 점프문

1. 자바스크립트 인터프리터가 소스 코드의 다른 위치로 이동하게 하는 문이다.

    - `break`
        - 인터프리터를 루프를 비롯한 다른 문의 끝으로 이동시킨다.
    - `continue`
        - 루프 바디의 나머지를 생략하고 루프 맨 위로 돌아가 새 반복을 시작하게 함.
    - `return`
        - 인터프리터가 함수에서 빠져나와 호출자에게 함수 호출 값을 전달하게 한다.
    - `yield`
        - [제너레이터 함수](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Generator)에서 사용하는 `return` 문과 비슷한 문이다.
            - 제너레이터 함수는 여러 개의 값을 필요에 따라 하나씩 반환할 수 있다.
            - 제너레이터를 만들려면 특별한 문법 구조, `function*`이 필요하다.
                - `next()` : `[yield](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/yield)` 표현식을 통해 yield된 값을 반환한다.
            ```jsx
            function* generator() {
                yield 1;
                yield 2;
                yield 3;
            }

            // 제너레이터 함수를 호출하면 코드가 실행되지 않고,
            // 대신 실행을 처리하는 특별 객체, '제너레이터 객체’가 반환
            const gen = generator(); // "Generator { }"

            console.log(gen.next().value); // 1
            console.log(gen.next().value); // 2
            console.log(gen.next().value); // 3
            ```
    - `throw`
        - 예외를 일으키는 문
            - 예외 처리를 담당하는 `try,catch,finally` 문과 함께 사용하도록 설계되었다.
            - 예외가 일어나면 인터프리터는 가장 가까운 예외 핸들러로 점프함.
                - 핸들러는 동일한 함수 안에 있을 수도 있고 콜 스택을 거슬러 올라가 호출자에게 있을 수도 있다.

    > 자바스크립트는 문에 라벨, 즉 이름을 붙일 수 있게 허용하는데 `break`와 `continue`는 이 라벨을 인식할 수 있다.

    ### 5.5.1 라벨 붙은 문

    1. 어떤 문이든 그 앞에 식별자와 콜론을 붙여서 라벨을 만들 수 있다.

        ```jsx
        identifier: statement;
        ```

        - 문에 라벨을 붙이는 것은 프로그램 다른 곳에서 참조할 수 있는 이름을 짓는 것과 같다.
        - 루프에 이름을 붙이면 루프 바디 안에서 `break`와 `continue` 문을 사용해 루프를 빠져나가거나 루프 맨 위로 점프해 다음 반복으로 넘어갈 수 있다.
            ```jsx
            mainloop: while (token !== null) {
                // 코드 생략
                continue mainloop;
                // 코드 생략
            }
            ```

    1. `identifier`
        - 유효한 자바스크립트 식별자 라면 예약어를 제외한 무엇이든 사용할 수 있다.
        - 라벨의 네임스페이스와 변수나 함수의 네임스페이스는 다르므로, 같은 식별자도 사용 가능하다.
        - 자신을 포함한 문과 같은 라벨을 붙일 수 없지만, 중첩되지 않은 두 문에는 같은 라벨을 붙일 수 있고 라벨 붙은 문을 모아서 다시 라벨을 붙일 수도 있다.
            - 즉, 모든 문은 여러 개의 라벨을 가질 수 있다.
