1. 배열은 값의 순서 있는 집합이다.
    - 각 값을 요소라고 부르며 각 요소에는 배열에서 차지하는 위치를 나타내는 숫자인 인덱스가 있다.
    - 배열 요소는 어떤 타입이든 상관없고, 배열 하나에 여러 타입이 섞여 있어도 괜찮다.
        - 배열 요소에 객체나 다른 배열을 써도 산관없으므로 객체로 이루어진 배열이나 배열로 이루어진 배열 같은 복잡한 데이터 구조를 만들 수도 있다.
2. 자바스크립트의 배열은 동적이다.
    - 필요한 만큼 커지거나 작아질 수 있고, 배열을 생성할 때 고정된 크기를 선언하거나 크기가 변할 때 배열을 재할당할 필요가 없다.
3. 자바스크립트는 성긴 배열을 허용한다.
    - 즉 요소의 인덱스가 꼭 이어질 필요는 없고 그 사이에 갭이 있어도 된다.
4. 자바스크립트 배열에는 모두 `length`프로퍼티가 있다.
5. 자바스크립트 배열은 객체의 특별한 형태이다.
    - 배열 인덱스는 프로퍼티 이름이 정수인 것과 별로 다르지 않다.
    - 자바스크립트 실행 환경은 일반적으로 배열을 최적화하므로 숫자로 인덱스된 배열 요소는 일반적인 객체 프로퍼티보다 상당히 빠르게 접근할 수 있다.
6. 배열은 `Array.prototype`에서 프로퍼티를 상속한다.
    - 이 프로토타입에는 배열 조작 메서드가 많이 포함되어 있다.
    - 이런 메서드는 대부분 배열뿐만 아니라 배열 비슷한 객체에서도 정확히 동작하는 범용 메서드이다.
7. ES6에서 형식화 배열이라 부르는 새로운 배열 클래스를 몇 가지 도입했다.
    - 형식화 배열은 일반적인 배열과 달리 길이가 고정적이며 요소 타입도 숫자로 고정되어 있다.
    - 형식화 배열은 아주 빠르고 이진 데이터에 바이트 수준으로 접근할 수 있다.

## 7.1 배열 생성

1. 배열을 만드는 여러가지 방식
    - 배열 리터럴
    - 이터러블 객체에 분해 연산자 … 적용
    - `Array()` 생성자
    - `Array.of()`와 `Array.from()` 팩토리 메서드

### 7.1.1. 배열 리터럴

1. 배열을 만드는 가장 단순한 방법이다.
    - 배열 요소를 대괄호 안에서 콤마로 구분한 리스트 형태이다.
        ```jsx
        let empty = []; // 빈 배열
        let primes = [2, 3, 5, 6, 11]; // 숫자 요소가 다섯 개 있는 배열
        let misc = [1.1, true, "a"]; // 타입이 다른 요소가 있는 배열
        ```
    - 임의의 표현식도 가능하다.
        ```jsx
        let base = 1024;
        let table = [base, base + 1, base + 2, base + 3];
        ```
    - 배열 리터럴 안에 객체 리터럴이나 다른 배열 리터럴도 가능하다.
        ```jsx
        let b = [{ x: 0, y: 0 }, [1, 2, 3, 4]];
        ```
    - 콤마 사이에 값이 없으면 성긴 배열이 만들어진다.
        - 값을 생략한 위치에 실제로 배열 요소가 존재하지는 않지만 검색하면 `undefined`가 반환된다.
        - 배열 리터럴 문법은 마지막에 콤마를 허용한다.
        ```jsx
        let count = [1, , 3];
        let undefs = [, ,]; // 요소가 없지만 길이가 2인 배열
        ```

### 7.1.2. 분해 연산자

1. ES6 이후에는 분해 연산자 …를 써서 배열 리터럴 안에 다른 배열 요소를 넣을 수 있다.

    ```jsx
    let a = [1, 2, 3];
    let b = [0, ...a, 4]; // [0,1,2,3,4]
    ```

    - 세 개의 점은 배열 `a`를 ‘분해'해서 그 요소를 새로 생성하는 배열 리터럴 요소로 만든다.

1. 분해 연산자는 배열을 얕게 복사할 때도 유용하다.

    ```jsx
    let original = [1, 2, 3];
    let copy = [...original];
    copy[0] = 0; // 사본을 수정해도 원본에는 영향이 없다.
    original[0]; // 1
    ```

    - 분해 연산자는 모든 이터러블 객체에 동작한다.
        - 이터러블 객체는 `for/of` 루프의 대상이 될 수 있는 객체이다.

### 7.1.3 Array() 생성자

1. `Array()` 생성자를 써서 배열을 만들 수도 있다.
    - 인자 없이 호출
        ```jsx
        let a = new Array();
        ```
        - 요소 없는 빈 배열을 생성하며 배열 리터럴 `[]`와 동등하다.
    - 배열 길이를 나타내는 숫자 인자 하나로 호출
        ```jsx
        let a = new Array(10);
        ```
        - 지정된 길이를 가진 배열을 생성한다.
        - 아직 배열에 값을 저장하지 않았고 배열 인데스도 아직 정의하지 않았다.
    - 배열 요소를 두 개 이상 쓰거나 숫자가 아닌 요소를 하나만 넘겨 호출
        ```jsx
        let a = new Array(5, 4, 3, 2, 1, "testing, testing");
        ```
        - 생성자의 인자가 새 배열의 요소가 된다.

### 7.1.4 Array.of()

1. Array() 생성자를 숫자 인자 하나만 넘겨 호출하면 길이가 그 숫자인 배열이 생성된다.
    - 숫자 인자가 하나 이상 있으면 이들 각각을 요소로 취급한다.
    - 따라서 Array() 생성자로는 숫자 요소가 하나만 있는 배열은 생성할 수 없다.
2. ES6의 Array.of() 함수는 인자릐 개수를 따지지 않고 각 인자를 새 배열의 요소로 사용한다.

    ```jsx
    Array.of(); // []
    Array.of(10); // [10]
    Array.of(1, 2, 3); // [1,2,3]
    ```

### 7.1.5 Array.from()

1. `Array.from()` 는 ES6에서 도입한 팩토리 메서드이다.

    - 이 메서드는 첫 번째 인자로 이터러블 객체나 배열 비슷한 객체를 받으며, 해당 객체의 요소로 새 배열을 만들어 반환한다.
        - `Array.from(iterable)` 은 분해 연산자를 사용한 `[…iterable]` 과 동등하다.

1. `Array.from()` 이 중요한 이유는 배열 비슷한 객체를 진정한 배열로 바꾸는 방법이기 때문이다.

    - 배열 비슷한 객체란?
        - 숫자인 `length` 프로퍼티가 있고, 이름이 정수인 프로퍼티에 값이 저장된 객체
    - 클라이언트 사이드 자바스크립트에서 웹 브라우저 메서드 일부가 배열 비슷한 객체를 반환하므로, 먼저 이들을 배열로 변환하면 작업이 간단해질 때가 많다.

1. `Array.from()` 은 선택 사항으로 두 번째 인자를 받는다.
    - 두 번째 인자로 함수를 전달하면, 새 배열을 생성할 때 소스 객체의 각 요소를 이 함수에 전달하고 반환 값을 배열에 저장한다.

## 7.2 배열 요소 읽기와 쓰기

1. 배열 요소에 접근할 때는 `[]`연산자를 사용한다.

    - 대괄호 왼쪽에는 배열 참조가 있어야한다.
    - 대괄호 안에는 양의 정수로 평가되는 표현식이 있어야 한다.
    - 이 문법은 배열 요소를 읽고 쓸 때 모두 사용할 수 있다.

    ```jsx
    let a = ["world"];
    let value = a[0]; // 인덱스 0을 읽는다.
    a[1] = 3.14; // 인덱스 1에 쓴다.
    let i = 2;
    a[i] = 3; // 인덱스 2에 쓴다.
    a[i + 1] = "hello"; // 인덱스 3에 쓴다.
    a[a[i]] = a[0]; // 인덱스 0과 2를 읽은 다음, 인덱스 3에 쓴다.
    ```

1. 배열은 특별하긴 하지만 결국 객체이다.

    - 배열 요소에 접근할 때 사용하는 대괄호는 객체 프로퍼티에 접근할 때 사용하는 대괄호와 마찬가지로 동작한다.
    - 자바스크립트는 숫자인 배열 인덱스를 문자열로 변환한다.
        - 즉, 인덱스 1은 문자열 “1”이 되며, 이 문자열을 프로퍼티 이름으로 사용한다.
    - 인덱스를 숫자에서 문자열로 변환하는 것은 특별한 일이 아니며 일반 객체에서도 똑같다.
        ```jsx
        let o = {};
        o[1] = "one";
        o["1"]; // one
        ```
    - 배열 인덱스에는 음수도, 정수가 아닌 숫자도 쓸 수 있다.
        - 이렇게 하면 숫자열을 문자열로 변환하고 그 문자열을 프로퍼티 이름으로 사용한다.
        - 이런 프로퍼티는 이름이 양의 정수가 아니므로 배열 인덱스가 아니라 일반적인 객체 프로퍼티로 취급한다.
    - 양의 정수로 평가되는 문자열을 인덱스로 사용하면 객체 프로퍼티가 아니라 배열 인덱스로 취급한다.
        - 부동 소수점 숫자도 마찬가지이다.

    ```jsx
    a[-1.23] = true; // -1.23이라는 프로퍼티가 생긴다.
    a["1000"] = 0; // 배열의 1001번째 요소이다.
    a[1.0] = 1; // 배열 인덱스 1, a[1] = 1 과 같다.
    ```

## 7.3 성긴 배열

1. 성긴 배열은 인덱스가 연속적이지 않은 배열이다.
    - 일반적으로 배열의 `length` 프로퍼티는 배열에 포함된 요소의 개수이다.
    - 하지만 성긴 배열의 경우 `length` 프로퍼티의 값이 요소 개수보다 크다.
2. 충분히 성긴 배열은 일반적으로 빽빽한 배열에 비해 좀 느리지만 메모리를 효율적으로 사용하는 방법으로 구현되며, 이런 배열에서 요소를 검색하는 시간은 일반적인 객체 프로퍼티 검색에 필요한 시간과 비슷하다.
    - 현실적으로 대부분의 자바스크립트 배열은 성기지 않은 배열이다.
    - 그리고 실제로 성긴 배열을 다뤄야 할 때가 있더라도, 아마 코드에서는 그 배열을 `undefined`요소가 포함된 빽빽한 배열로 취급할 것이다.

## 7.4 배열 길이

1. 모든 배열에는 `length` 프로퍼티가 있으며 이 프로퍼티는 일반적인 자바스크립트 객체와 배열을 구분하는 특징이다.

    - 빽빽한 배열에서 `length` 프로퍼티는 배열에 포함된 요소 개수와 같다.
        - 그 값은 배열에서 가장 큰 인덱스에 `1`을 더한 값이다.
    - 성긴 배열의 `length` 프로퍼티는 포함된 요소 개수보다 크다.
    - 확실히 알 수 있는 것은 `length` 가 가장 큰 인덱스보다 더 크다는 사실이다.
        - 달리 말하자면 배열에는 `length` 보다 크거나 같은 인덱스는 존재하지 않는다.

1. 자바스크립트 배열에는 두 가지 특별한 동작이 있다.
    - 배열의 현재 길이 이상인 `i` 인덱스에 값을 할당할 때 `length` 프로퍼티를 `i + 1`로 갱신하는 동작
    - 배열의 `length` 프로퍼티를 현재 값보다 작은 양의 정수 `n`으로 지정할때 인덱스가 `n`이상인 배열 요소는 모두 삭제하는 동작
        ```jsx
        a = [1, 2, 3, 4, 5]; // 요소가 다섯 개 있는 배열로 시작한다.
        a.length = 3; // a는 이제 [1,2,3]
        a.length = 0; // 요소 전체를 삭제한다. a는 []
        a.length = 5; // 길이는 5이지만 new Array(5)와 마찬가지로 요소는 없다.
        ```
        - `length` 프로퍼티를 현재 값보다 큰 값으로 설정할 수도 있다.
            - 이렇게 해도 실제로 새 요소가 배열에 추가되는 것은 아니며 배열 마지막에 성긴 영역이 생길 뿐 이다.

## 7.5 배열 요소 추가와 삭제

1. 배열에 요소를 추가하는 가장 단순한 방법은 새 인덱스에 값을 할당하는 방법이다.

    ```jsx
    let a = [];
    a[0] = "zero";
    a[1] = "one";
    ```

    - `push()`메서드는 배열 마지막에 값을 추가한다.
        ```jsx
        let a = [];
        a.push("zero"); // 마지막에 값을 추가한다 . ['zero']
        a.push("one", "two"); // 값을 두개 더 추가한다. ['zero', 'one', 'two']
        ```
        - `push()`는 `a[a.length]`에 값을 할당하는 것과 같다.
    - `unshift()`메서드는 배열의 맨 앞에 값을 삽입하고 기존 요소를 뒤로 민다.
    - `pop()`메서드는 `push()`의 반대로 배열의 마지막 요소를 제거하고 그 값을 반환하며 배열의 길이를 1만큼 줄인다.
    - `shift()`메서드는 배열의 첫 번째 요소를 제거해 반환하며 길이를 1만큼 줄이고 나머지 요소를 모두 앞으로 당긴다.

1. `delete` 연산자로 배열 요소를 삭제 할 수도 있다.

    ```jsx
    let a = [1, 2, 3];
    delete a[2]; // 이제 a의 인덱스 2에 요소가 없다.
    2 in a; // false
    a.length; // 3 delete는 배열 길이에 영향을 주지 않는다.
    ```

    - 배열 요소를 삭제하는 것은 그 요소에 `undefined`를 할당하는 것과 비슷하다.
        - 완전히 같지는 않다.
    - 배열 요소에 `delete` 를 사용하더라도 `length` 프로퍼티는 변하지 않으면 빈 공간을 메우기 위해 요소가 이동되지도 않는다.
    - 배열 요소를 삭제하면 그 배열은 성긴 배열이 된다.

1. `legnth` 프로퍼티를 수정해서 배열의 맨 뒤에서부터 요소를 삭제할 수도 있다.

1. 배열 요소를 삽입, 삭제, 대체하는 범용 메서드인 `splice()`도 있다.

## 7.6 배열 순회

1. ES6이후 배열 요소나 이러터블 객체를 순회하는 가장 쉬운 방법은 `for/of`이다.

    - `for/of` 루프가 사용하는 내장 이터레이터는 오름차순으로 요소를 반환한다.
    - 성긴 배열도 마찬가지이며 존재하지 않는 배열 요소에 대해서는 `undefined`를 반환한다.

1. 배열에 `for/of` 루프를 적용할 때 각 요소의 인덱스가 필요하다면 `entries()` 메서드와 분해 할당을 이용하면 된다.

    ```jsx
    let letters = [..."Hello world"];
    let everyother = "";

    for (let [index, letter] of letters.entries()) {
        if (index % 2 === 0) everyother += letter; // 짝수 번째 인덱스의 글자
    }

    everyother; // "Hlowrd"
    ```

1. `forEach()`도 배열을 순회하는 좋은 방법이다.

    - 이 메서드는 `for` 루프의 변형이 아니라 배열 순회를 함수형으로 바꾼 배열 메서드이다.
    - `forEach()`는 전달받은 함수를 각 배열 요소에서 호출한다.

    ```jsx
    let letters = [..."Hello world"];

    let uppercase = "";
    letters.forEach((letter) => {
        uppercase += letter.toUpperCase();
    });

    uppercase; // "HELLO WORLD"
    ```

    - `forEach()`는 배열을 순서대로 순회하며 배열 인덱스를 함수의 두번째 인자로 전달한다.
    - for/of 루프와 달리 forEach()는 성긴 배열을 인식하고 존재하지 않는 요소에 대해서는 함수를 호출하지 않는다.
        ```jsx
        let a = [1, 2, 3];
        delete a[1];
        a.forEach((n) => {
            console.log(n);
        });

        // 1
        // 3

        let b = [1, 2, 3];
        b[1] = undefined;
        b.forEach((n) => {
            console.log(n);
        });

        // 1
        // undefined
        // 3
        ```

## 7.7 다차원 배열

1. 자바스크립트에서 다차원 배열을 직접 지원하지는 않지만 배열의 배열을 만들어 대략적으로 흉내 낼 수는 있다.
    - 내부 배열의 값에 접근할 때는 `[]`연산자를 이중으로 쓰기만 하면 된다.

## 7.8 배열 메서드

1. 배열 메서드는 몇가지 그룹으로 묶을 수 있다.

    - 배열 요소를 순회하는 이터레이터 메서드
        - 이들은 일반적으로 각 요소에 대해 함수를 호출한다.
    - 배열의 앞이나 뒤에 요소를 추가하거나 제거하는 스택, 큐 메서드
    - 큰 배열을 추출, 삭제, 삽입, 충당, 복사하는 하위 배열 메서드
    - 배열을 검색하고 정렬하는 메서드

    ### 7.8.1 배열 이터레이터 메서드

    1. 메서드는 배열 요소를 순서대로 함수에 전달하는 방식으로 동작하며 배열 요소를 순회, 변환, 필터, 체크, 축소할 수 있다.

        - 이러한 메서드에 대한 몇가지 일반화
            - 모두 첫번째 인자로 함수를 받으며 각 배열 요소(또는 일부 요소)에 대해 그 함수를 한 번씩 호출한다.
            - 성긴 배열이라면 존재하지 않는 요소에 대해서는 함수를 호출하지 않는다.
            - 대부분의 경우 이 함수는 배열 요소의 값, 인덱스, 배열 자체 세가지 인자를 받는다.

    1. 다음 설명하는 이터레이터 메서드 대부분은 선택 사항으로 두번째 인자를 받는다.

        - 두번째 인자를 지정했다면 첫번째 인자인 함수는 자신이 그 두번째 인자의 메서드인 것처럼 호출된다.
            - 즉 두번째 인자가 함수의 `this`가 된다.

    1. 여기서 설명하는 메서드 중 원래 배열을 수정하는 메서드는 없다.

        - 물론 전달하는 함수가 원래 배열을 수정할 수는 있다.

        ### forEach()

        1. `forEach()` 메서드는 배열을 순회하며 각 요소에서 함수를 호출한다.

            - 첫번째 인자는 함수다.
                - `forEach()`는 배열 요소의 값, 배열 요소의 인덱스, 배열 자체를 인자로 전달해 이 함수를 호출한다.
            - 배열 요소의 값에만 관심이 있다면 인자 하나만 받는 함수를 작성하고 나머지는 무시해도 된다.

            ```jsx
            let data = [1, 2, 3, 4, 5],
                sum = 0;

            // 배열 요소의 합을 계산한다.
            data.forEach((value) => {
                sum += value;
            }); // sum == 15

            // 배열 요소를 각각 증가시킨다.
            data.forEach(function (v, i, a) {
                a[i] = v + 1;
            }); // data == [2,3,4,5,6]
            ```

            - `forEach()`에서 모든 요소를 함수에 전달하기 전에 반복을 멈추는 방법은 없다.

        ### map()

        1. `map()` 메서드는 각 배열 요소를 함수에 전달해 호출하며, 그 함수가 반환한 값으로 이루어진 배열을 반환한다.

            ```jsx
            let a = [1, 2, 3];
            a.map((x) => x * x); // [1,4,9]
            ```

        1. `map()`에 전달하는 함수는 `forEach()`에 전달하는 함수와 같은 방법으로 호출된다.
            - 하지만 `map()`메서드에 전달하는 함수는 값을 반환해야 한다.
            - `map()`은 새 배열을 반환하며 기존 배열은 수정하지 않는다.
            - 성긴 배열이라면 존재하지 않는 요소에 대해서는 함수를 호출하지 않지만, 반환된 배열 역시 같은 위치에 갭이 있으며 길이 또한 같다.

        ### filter()

        1. `filter()` 메서드는 기존 배열의 일부만 포함하는 부분 집합을 반환한다.

            - 전달하는 함수를 기준으로 하며 이 함수는 `true` 또는 `false`를 반환한다.
            - 반환 값이 `true`이거나 `true`로 변환될 수 있는 값이면, 해당 요소는 반환되는 배열에 포함된다.

            ```jsx
            let a = [5, 4, 3, 2, 1];
            a.filter((x) => x < 3); // [2,1] 3미만의 값
            a.filter((x, i) => i % 2 === 0); // [5, 3, 1]; 인덱스가 짝수인 값
            ```

        1. `filter()`는 성긴 배열에서 존재하지 않는 값은 건너뛰며, 반환하는 배열은 항상 빽빽한 배열이다.
            - `filter()`를 써서 갭과 함께 `undefined`, `null` 요소도 제거할 수 있다.
                ```jsx
                a = a.filter((x) => x !== undefined && x !== null);
                ```

        ### find()와 findIndex()

        1. `find()`와 `findIndex()` 메서드는 판별 함수에서 `true` 같은 값을 반환하는 요소를 찾아 배열을 순회한다는 점은 `filter()`와 같다.

            - 하지만 `filter()`와 달리 이들 메서드는 기준을 만족하는 첫 번째 요소를 찾는 즉시 순회를 멈춘다.
            - 만족하는 요소를 찾으면 `find()`는 그 요소를, `findIndex()`는 그 요소의 인덱스를 반환한다.
            - 만족하는 요소를 찾지 못하면 `find()`는 `undefined`를 `findIndex()`는 `-1`을 반환한다.

            ```jsx
            let a = [1, 2, 3, 4, 5];
            a.findIndex((x) => x === 3); // 2
            a.findIndex((x) => x < 0); // -1
            a.find((x) => x % 5 === 0); // 5
            a.find((x) => x % 7 === 0); // undefined
            ```

        ### every()와 some()

        1. `every()`와 `some()` 메서드는 배열 요소에 판별 함수를 적용하고 결과에 따라 true 또는 false를 반환한다.

            - `every()` 메서드는 판별 함수가 배열의 모든 요소에 대해 `true`를 반환할 때만 `true`를 반환한다.
                ```jsx
                let a = [1, 2, 3, 4, 5];
                a.every((x) => x < 10); // true
                a.every((x) => x % 2 === 0); // false
                ```
            - `some()` 메서드는 배열 요소 중 판별 함수가 `true`를 반환하는 것이 하나라도 있으면 `true`를 반환하며, 요소 전체가 `false`를 반환할 때만 `false`를 반환한다.
                ```jsx
                let a = [1, 2, 3, 4, 5];
                a.some((x) => x % 2 === 0); // true
                a.some(isNaN); // false
                ```

        1. `every()`와 `some()`은 자신이 어떤 값을 반환할지 확실해지는 순간 순회를 멈춘다.

            - `some()`은 판별 함수가 `true`를 반환하는 즉시 `true`를 반환하므로 모든 요소가 `false`를 반환할 때만 배열 전체를 순회한다. ( 마지막 요소가 `true`를 반환할때를 제외 )
            - `every()`는 반대로 판별 함수가 `false`를 반환하는 즉시 `false`를 반환하므로 모든 요소가 `true`를 반환할 때만 배열 전체를 순회한다. ( 마지막 요소가 `false`를 반환할때를 제외 )

        1. 빈 배열에 호출했을 때 `every()`는 `true`를 `some()`은 `false`를 반환한다.

    ### reduce()와 reduceRight()

    1. `reduce()`와 `reduceRight()` 메서드는 제공하는 함수를 사용해 배열 요소를 하나의 값으로 만든다.

        ```jsx
        let a = [1, 2, 3, 4, 5];
        a.reduce((x, y) => x + y, 0); // 15
        a.reduce((x, y) => x * y, 0); // 120
        a.reduce((x, y) => (x > y ? x : y)); // 5
        ```

    1. `reduce()`

        - `reduce()`는 인자 두개를 받는다.
            - 첫번째는 ‘축소’ 동작을 행하는 함수이다.
                - 이 함수가 하는 일은 어떤 방식이로든 값 두개를 받아서 하나를 반환하는 것이다.
            - 두번째 인자는 선택 사항이며 함수에 전달할 초기값이다.
        - `reduce()`에 사용하는 함수는 `forEach()`나 `map()`에 사용하는 함수와는 다르다.
            - 값, 인덱스, 배열은 각각 두번째, 세번째, 네번째 인자로 전달된다.
            - 첫번째 인자는 여태까지 행한 ‘축소’ 작업의 결과이다.
            - 함수를 처음 호출할 때는 그동안 행한 작업이 없으니 `reduce()`의 두번째 인자로 전달한 초깃값을 사용한다.
                - 두번째 이후에는 이전 호출에서 반환한 값을 사용한다.
        - `reduce()`에 초기값을 넘기지 않으면 배열의 첫번째 요소를 초깃값으로 사용한다.
            - 이렇게 호출하면 함수를 첫번째로 호출할 때 첫번째와 두번째 인자는 배열의 첫번째와 두번째 요소이다.
        - 빈 배열에 초기값 없이 `reduce()`를 호출하면 `TypeError`가 일어난다.
            - 값이 하나만 있는 배열에서 초깃값을 생략하고 호출하거나, 빈 배열에 초깃값을 넘기면서 호출하는 등 `reduce()`에 값을 하나만 넘기면 그 값을 그대로 반환하며 함수는 호출하지도 않는다.

    1. `reduceRight()`는 `reduce()`와 마찬가지지만 오른쪽에서 왼쪽으로 진행한다는 점이 다르다.

        - 축소 동작의 결합성이 오른쪽에서 왼쪽일 경우 이 메서드가 유용할 수 있다.

    1. `reduce()`나 `reduceRight()`는 축소 함수에서 this로 사용될 인자는 받지 않는다.

    1. `reduce()`와 `reduceRight()`는 같은 타입의 두 값을 하나로 조합할 수 있는 함수라면 무엇이든 축소 함수로 사용할 수 있다.

    ### 7.8.2 flat()과 flatMap()을 사용한 배열 평탄화

    1. ES2019에서 도입한 `flat()` 메서드는 기존 배열과 같은 요소로 이루어진 ‘평탄한’ 즉, 중첩되지 않는 새 배열을 반환합니다.

        ```jsx
        [1, [2, 3]].flat(); // [1,2,3]
        [1, [2, [3]]].flat(); // [1,2,[3]]
        ```

        - 인자 없이 `flat()`을 호출하면 한 단계만 평탄화한다.
        - 평탄화 레벨을 늘리려면 `flat()`에 숫자를 전달하면 된다.
            ```jsx
            let a = [1, [2, [3, [4]]]];
            a.flat(1); // [1, 2 , [3, [4]]]
            a.flat(2); // [1, 2 , 3, [4]]
            a.flat(3); // [1, 2 , 3 , 4]
            a.flat(4); // [1, 2 , 3 , 4]
            ```

    1. `flatMap()` 메서드는 map() 메서드와 똑같이 동작하지만, 반환하는 배열이 flat()에 전달한 것처럼 자동으로 평탄화한다는 점이 다르다.

        - 즉 `a.flatMap(f)`는 `a.map(f).flat()`과 동등하다.
            - 하지만 더 효율적이다.

        ```jsx
        let phrases = ["hello world", "the definitive guide"];
        let words = phrases.flatMap((phrase) => phrase.split(" "));
        words; // ['hello', 'world', 'the', 'definitive', 'guide']
        ```

        - `flatMap()`을 기존 배열의 각 요소를 결과 배열로 ‘분해’하는 일반화된 map()이라고 생각해도 좋다.
        - 사용하기에 따라서는 기존 배열의 요소 일부를 빈 배열로 바꿔, 평탄화를 거치면 결과 배열에는 아무것도 남지 않게 할 수 있다.
            ```jsx
            // 음이 아닌 숫자의 제곱근을 구한다.
            [-2, -1, 1, 2].flatMap((x) => (x < 0 ? [] : Math.sqrt(x))); // [1, 2**0.5]
            ```

    ### 7.8.3 concat()으로 배열 병합

    1. `concat()` 메서드는 기존 배열의 요소를 포함하고 그 뒤에 `concat()` 의 인자를 포함하는 새 배열을 만들어 반환한다.

        - 인자에 배열이 들어 있으면 배열이 아니라 그 요소를 추가한다.
        - 하지만 `concat()` 은 배열의 배열을 재귀적으로 평탄화하지는 않는다.
        - `concat()` 은 기존 배열을 수정하지 않는다.

        ```jsx
        let a = [1, 2, 3];
        a.concat(4, 5); // [1,2,3,4,5]
        a.concat([4, 5], [6, 7]); // [1,2,3,4,5,6,7]
        a.concat(4, [5, [6, 7]]); // [1,2,3,4,5,[6,7]]
        a; // [1,2,3]
        ```

    1. `concat()` 은 원래 배열의 사본을 만들어 반환한다.
        - 대게는 이렇게 하는 것이 맞기는 하지만, 이는 비용이 드는 작업이다.
        - `a = a.concat(x)` 같은 코드를 자주 쓰고 있으면 `push()`나 `splice()`를 대신 쓸 수도 있다.

    ### 7.8.4 스택과 큐 메서드

    1. `push()`와 `pop()` 메서드는 배열을 스택처럼 다루는 메서드이다.

        - `push()` 메서드는 배열의 끝에 하나 이상의 새 요소를 추가하고 새 길이를 반환한다.
        - `push()`는 배열 인자를 평탄화하지 않는다.
        - `pop()`은 그 반대로 배열의 마지막 요소를 꺼내서 반환하며 배열 길이를 줄인다.
        - 두 메서드 모두 기존 배열을 수정한다.

        ```jsx
        let stack = []; // []
        stack.push(1, 2); // [1,2]
        stack.pop(); // [1]
        stack.push(3); // [1,3]
        stack.pop(); // [1]
        stack.push([4, 5]); // [1,[4,5]]
        stack.pop(); // [1]
        stack.pop(); // []
        ```

        - `push()` 메서드는 전달한 배열을 평탄화하지 않는다.
            - 배열 요소를 다른 배열에 모두 넣고 싶다면 분해 연산자를 직접 사용해 평탄화할 수 있다.

    2. `unshift()`와 `shift()` 메서드는 `push(), pop()`과 거의 비슷하지만 배열의 마지막이 아니라 앞부분에서 이루어진다는 것이 다르다.

        - `unshift()`는 배열의 시작 부분에 요소를 추가하고, 기존의 배열 요소를 뒤로 밀고, 새 길이를 반환한다.
        - `shift()`는 배열의 첫번째 요소를 꺼내 반환하고, 기존의 배열 요소를 앞으로 당긴다.
        - `unshift()`와 `shift()`를 써서 배열을 스택처럼 사용할 수 있긴 하지만, 명령할 때마다 기존 배열 요소를 앞뒤로 미는 작업이 수반되어야 하므로 `push()`나 `pop()`에 비해 비효율적이다.

        ```jsx
        let q = []; // []
        q.push(1, 2); // [1,2]
        a.shift(); // [2]
        a.push(3); // [1,3]
        a.shift(); // [3]
        a.shift(); // []
        ```

        - `unshift()`에 인자 여러 개를 전달하면 이들은 모두 한번에 삽입되므로 한 번에 하나씩 삽입했을 때와 결과가 다르다.
            ```jsx
            let a = []; // []
            a.unshift(1); // [1]
            a.unshift(2); // [2,1]
            a = []; // []
            a.unshift(1, 2); // [1,2]
            ```

### 7.8.5 하위 배열

1. 배열에는 일종의 연속적인 영역인 하위 배열, ‘슬라이스’를 다루는 메서드도 있다.

### slice()

1. `slice()` 메서드는 지정된 배열의 하위 배열을 반환한다.

    - 두 개의 인자는 각각 반환될 스라이스의 시작과 끝 위치를 나타낸다.
    - 반환된 배열에는 첫 번째 인자로 지정된 요소에서 시작해, 두 번째 인자로 지정된 요소 바로 앞까지가 포함된다.
    - 인자를 하나만 사용한다면 반환된 배열은 해당 위치부터 원래 배열의 마지막 요소까지 포함한다.
    - 인자에 음수를 사용한다면 그 값에 배열 길이를 더한 값을 적용한다.
        - 예를 들어 -1은 배열의 마지막 요소이고, -2는 마지막에서 바로 앞요소이다.
    - `slice()`는 원래 배열을 수정하지 않는다.

    ```jsx
    let a = [1, 2, 3, 4, 5];
    a.slice(0, 3); // [1,2,3]
    a.slice(3); // [4,5]
    a.slice(1, -1); // [2,3,4]
    a.slice(-3, -2); // [3]
    ```

### splice()
