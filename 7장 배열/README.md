1. 배열은 값의 순서 있는 집합이다.
    - 각 값을 요소라고 부르며 각 요소에는 배열에서 차지하는 위치를 나타내는 숫자인 인덱스가 있다.
    - 배열 요소는 어떤 타입이든 상관없고, 배열 하나에 여러 타입이 섞여 있어도 괜찮다.
        - 배열 요소에 객체나 다른 배열을 써도 산관없으므로 객체로 이루어진 배열이나 배열로 이루어진 배열 같은 복잡한 데이터 구조를 만들 수도 있다.
2. 자바스크립트의 배열은 동적이다.
    - 필요한 만큼 커지거나 작아질 수 있고, 배열을 생성할 때 고정된 크기를 선언하거나 크기가 변할 때 배열을 재할당할 필요가 없다.
3. 자바스크립트는 성긴 배열을 허용한다.
    - 즉 요소의 인덱스가 꼭 이어질 필요는 없고 그 사이에 갭이 있어도 된다.
4. 자바스크립트 배열에는 모두 `length`프로퍼티가 있다.
5. 자바스크립트 배열은 객체의 특별한 형태이다.
    - 배열 인덱스는 프로퍼티 이름이 정수인 것과 별로 다르지 않다.
    - 자바스크립트 실행 환경은 일반적으로 배열을 최적화하므로 숫자로 인덱스된 배열 요소는 일반적인 객체 프로퍼티보다 상당히 빠르게 접근할 수 있다.
6. 배열은 `Array.prototype`에서 프로퍼티를 상속한다.
    - 이 프로토타입에는 배열 조작 메서드가 많이 포함되어 있다.
    - 이런 메서드는 대부분 배열뿐만 아니라 배열 비슷한 객체에서도 정확히 동작하는 범용 메서드이다.
7. ES6에서 형식화 배열이라 부르는 새로운 배열 클래스를 몇 가지 도입했다.
    - 형식화 배열은 일반적인 배열과 달리 길이가 고정적이며 요소 타입도 숫자로 고정되어 있다.
    - 형식화 배열은 아주 빠르고 이진 데이터에 바이트 수준으로 접근할 수 있다.

## 7.1 배열 생성

1. 배열을 만드는 여러가지 방식
    - 배열 리터럴
    - 이터러블 객체에 분해 연산자 … 적용
    - `Array()` 생성자
    - `Array.of()`와 `Array.from()` 팩토리 메서드

### 7.1.1. 배열 리터럴

1. 배열을 만드는 가장 단순한 방법이다.
    - 배열 요소를 대괄호 안에서 콤마로 구분한 리스트 형태이다.
        ```jsx
        let empty = []; // 빈 배열
        let primes = [2, 3, 5, 6, 11]; // 숫자 요소가 다섯 개 있는 배열
        let misc = [1.1, true, "a"]; // 타입이 다른 요소가 있는 배열
        ```
    - 임의의 표현식도 가능하다.
        ```jsx
        let base = 1024;
        let table = [base, base + 1, base + 2, base + 3];
        ```
    - 배열 리터럴 안에 객체 리터럴이나 다른 배열 리터럴도 가능하다.
        ```jsx
        let b = [{ x: 0, y: 0 }, [1, 2, 3, 4]];
        ```
    - 콤마 사이에 값이 없으면 성긴 배열이 만들어진다.
        - 값을 생략한 위치에 실제로 배열 요소가 존재하지는 않지만 검색하면 `undefined`가 반환된다.
        - 배열 리터럴 문법은 마지막에 콤마를 허용한다.
        ```jsx
        let count = [1, , 3];
        let undefs = [, ,]; // 요소가 없지만 길이가 2인 배열
        ```

### 7.1.2. 분해 연산자

1. ES6 이후에는 분해 연산자 …를 써서 배열 리터럴 안에 다른 배열 요소를 넣을 수 있다.

    ```jsx
    let a = [1, 2, 3];
    let b = [0, ...a, 4]; // [0,1,2,3,4]
    ```

    - 세 개의 점은 배열 `a`를 ‘분해'해서 그 요소를 새로 생성하는 배열 리터럴 요소로 만든다.

1. 분해 연산자는 배열을 얕게 복사할 때도 유용하다.

    ```jsx
    let original = [1, 2, 3];
    let copy = [...original];
    copy[0] = 0; // 사본을 수정해도 원본에는 영향이 없다.
    original[0]; // 1
    ```

    - 분해 연산자는 모든 이터러블 객체에 동작한다.
        - 이터러블 객체는 `for/of` 루프의 대상이 될 수 있는 객체이다.

### 7.1.3 Array() 생성자

1. `Array()` 생성자를 써서 배열을 만들 수도 있다.
    - 인자 없이 호출
        ```jsx
        let a = new Array();
        ```
        - 요소 없는 빈 배열을 생성하며 배열 리터럴 `[]`와 동등하다.
    - 배열 길이를 나타내는 숫자 인자 하나로 호출
        ```jsx
        let a = new Array(10);
        ```
        - 지정된 길이를 가진 배열을 생성한다.
        - 아직 배열에 값을 저장하지 않았고 배열 인데스도 아직 정의하지 않았다.
    - 배열 요소를 두 개 이상 쓰거나 숫자가 아닌 요소를 하나만 넘겨 호출
        ```jsx
        let a = new Array(5, 4, 3, 2, 1, "testing, testing");
        ```
        - 생성자의 인자가 새 배열의 요소가 된다.

### 7.1.4 Array.of()

1. Array() 생성자를 숫자 인자 하나만 넘겨 호출하면 길이가 그 숫자인 배열이 생성된다.
    - 숫자 인자가 하나 이상 있으면 이들 각각을 요소로 취급한다.
    - 따라서 Array() 생성자로는 숫자 요소가 하나만 있는 배열은 생성할 수 없다.
2. ES6의 Array.of() 함수는 인자릐 개수를 따지지 않고 각 인자를 새 배열의 요소로 사용한다.

    ```jsx
    Array.of(); // []
    Array.of(10); // [10]
    Array.of(1, 2, 3); // [1,2,3]
    ```

### 7.1.5 Array.from()

1. `Array.from()` 는 ES6에서 도입한 팩토리 메서드이다.

    - 이 메서드는 첫 번째 인자로 이터러블 객체나 배열 비슷한 객체를 받으며, 해당 객체의 요소로 새 배열을 만들어 반환한다.
        - `Array.from(iterable)` 은 분해 연산자를 사용한 `[…iterable]` 과 동등하다.

1. `Array.from()` 이 중요한 이유는 배열 비슷한 객체를 진정한 배열로 바꾸는 방법이기 때문이다.

    - 배열 비슷한 객체란?
        - 숫자인 `length` 프로퍼티가 있고, 이름이 정수인 프로퍼티에 값이 저장된 객체
    - 클라이언트 사이드 자바스크립트에서 웹 브라우저 메서드 일부가 배열 비슷한 객체를 반환하므로, 먼저 이들을 배열로 변환하면 작업이 간단해질 때가 많다.

1. `Array.from()` 은 선택 사항으로 두 번째 인자를 받는다.
    - 두 번째 인자로 함수를 전달하면, 새 배열을 생성할 때 소스 객체의 각 요소를 이 함수에 전달하고 반환 값을 배열에 저장한다.
