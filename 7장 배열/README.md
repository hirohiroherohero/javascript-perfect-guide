1. 배열은 값의 순서 있는 집합이다.
    - 각 값을 요소라고 부르며 각 요소에는 배열에서 차지하는 위치를 나타내는 숫자인 인덱스가 있다.
    - 배열 요소는 어떤 타입이든 상관없고, 배열 하나에 여러 타입이 섞여 있어도 괜찮다.
        - 배열 요소에 객체나 다른 배열을 써도 산관없으므로 객체로 이루어진 배열이나 배열로 이루어진 배열 같은 복잡한 데이터 구조를 만들 수도 있다.
2. 자바스크립트의 배열은 동적이다.
    - 필요한 만큼 커지거나 작아질 수 있고, 배열을 생성할 때 고정된 크기를 선언하거나 크기가 변할 때 배열을 재할당할 필요가 없다.
3. 자바스크립트는 성긴 배열을 허용한다.
    - 즉 요소의 인덱스가 꼭 이어질 필요는 없고 그 사이에 갭이 있어도 된다.
4. 자바스크립트 배열에는 모두 `length`프로퍼티가 있다.
5. 자바스크립트 배열은 객체의 특별한 형태이다.
    - 배열 인덱스는 프로퍼티 이름이 정수인 것과 별로 다르지 않다.
    - 자바스크립트 실행 환경은 일반적으로 배열을 최적화하므로 숫자로 인덱스된 배열 요소는 일반적인 객체 프로퍼티보다 상당히 빠르게 접근할 수 있다.
6. 배열은 `Array.prototype`에서 프로퍼티를 상속한다.
    - 이 프로토타입에는 배열 조작 메서드가 많이 포함되어 있다.
    - 이런 메서드는 대부분 배열뿐만 아니라 배열 비슷한 객체에서도 정확히 동작하는 범용 메서드이다.
7. ES6에서 형식화 배열이라 부르는 새로운 배열 클래스를 몇 가지 도입했다.
    - 형식화 배열은 일반적인 배열과 달리 길이가 고정적이며 요소 타입도 숫자로 고정되어 있다.
    - 형식화 배열은 아주 빠르고 이진 데이터에 바이트 수준으로 접근할 수 있다.

## 7.1 배열 생성

1. 배열을 만드는 여러가지 방식
    - 배열 리터럴
    - 이터러블 객체에 분해 연산자 … 적용
    - `Array()` 생성자
    - `Array.of()`와 `Array.from()` 팩토리 메서드

### 7.1.1. 배열 리터럴

1. 배열을 만드는 가장 단순한 방법이다.
    - 배열 요소를 대괄호 안에서 콤마로 구분한 리스트 형태이다.
        ```jsx
        let empty = []; // 빈 배열
        let primes = [2, 3, 5, 6, 11]; // 숫자 요소가 다섯 개 있는 배열
        let misc = [1.1, true, "a"]; // 타입이 다른 요소가 있는 배열
        ```
    - 임의의 표현식도 가능하다.
        ```jsx
        let base = 1024;
        let table = [base, base + 1, base + 2, base + 3];
        ```
    - 배열 리터럴 안에 객체 리터럴이나 다른 배열 리터럴도 가능하다.
        ```jsx
        let b = [{ x: 0, y: 0 }, [1, 2, 3, 4]];
        ```
    - 콤마 사이에 값이 없으면 성긴 배열이 만들어진다.
        - 값을 생략한 위치에 실제로 배열 요소가 존재하지는 않지만 검색하면 `undefined`가 반환된다.
        - 배열 리터럴 문법은 마지막에 콤마를 허용한다.
        ```jsx
        let count = [1, , 3];
        let undefs = [, ,]; // 요소가 없지만 길이가 2인 배열
        ```

### 7.1.2. 분해 연산자

1. ES6 이후에는 분해 연산자 …를 써서 배열 리터럴 안에 다른 배열 요소를 넣을 수 있다.

    ```jsx
    let a = [1, 2, 3];
    let b = [0, ...a, 4]; // [0,1,2,3,4]
    ```

    - 세 개의 점은 배열 `a`를 ‘분해'해서 그 요소를 새로 생성하는 배열 리터럴 요소로 만든다.

1. 분해 연산자는 배열을 얕게 복사할 때도 유용하다.

    ```jsx
    let original = [1, 2, 3];
    let copy = [...original];
    copy[0] = 0; // 사본을 수정해도 원본에는 영향이 없다.
    original[0]; // 1
    ```

    - 분해 연산자는 모든 이터러블 객체에 동작한다.
        - 이터러블 객체는 `for/of` 루프의 대상이 될 수 있는 객체이다.

### 7.1.3 Array() 생성자

1. `Array()` 생성자를 써서 배열을 만들 수도 있다.
    - 인자 없이 호출
        ```jsx
        let a = new Array();
        ```
        - 요소 없는 빈 배열을 생성하며 배열 리터럴 `[]`와 동등하다.
    - 배열 길이를 나타내는 숫자 인자 하나로 호출
        ```jsx
        let a = new Array(10);
        ```
        - 지정된 길이를 가진 배열을 생성한다.
        - 아직 배열에 값을 저장하지 않았고 배열 인데스도 아직 정의하지 않았다.
    - 배열 요소를 두 개 이상 쓰거나 숫자가 아닌 요소를 하나만 넘겨 호출
        ```jsx
        let a = new Array(5, 4, 3, 2, 1, "testing, testing");
        ```
        - 생성자의 인자가 새 배열의 요소가 된다.

### 7.1.4 Array.of()

1. Array() 생성자를 숫자 인자 하나만 넘겨 호출하면 길이가 그 숫자인 배열이 생성된다.
    - 숫자 인자가 하나 이상 있으면 이들 각각을 요소로 취급한다.
    - 따라서 Array() 생성자로는 숫자 요소가 하나만 있는 배열은 생성할 수 없다.
2. ES6의 Array.of() 함수는 인자릐 개수를 따지지 않고 각 인자를 새 배열의 요소로 사용한다.

    ```jsx
    Array.of(); // []
    Array.of(10); // [10]
    Array.of(1, 2, 3); // [1,2,3]
    ```

### 7.1.5 Array.from()

1. `Array.from()` 는 ES6에서 도입한 팩토리 메서드이다.

    - 이 메서드는 첫 번째 인자로 이터러블 객체나 배열 비슷한 객체를 받으며, 해당 객체의 요소로 새 배열을 만들어 반환한다.
        - `Array.from(iterable)` 은 분해 연산자를 사용한 `[…iterable]` 과 동등하다.

1. `Array.from()` 이 중요한 이유는 배열 비슷한 객체를 진정한 배열로 바꾸는 방법이기 때문이다.

    - 배열 비슷한 객체란?
        - 숫자인 `length` 프로퍼티가 있고, 이름이 정수인 프로퍼티에 값이 저장된 객체
    - 클라이언트 사이드 자바스크립트에서 웹 브라우저 메서드 일부가 배열 비슷한 객체를 반환하므로, 먼저 이들을 배열로 변환하면 작업이 간단해질 때가 많다.

1. `Array.from()` 은 선택 사항으로 두 번째 인자를 받는다.
    - 두 번째 인자로 함수를 전달하면, 새 배열을 생성할 때 소스 객체의 각 요소를 이 함수에 전달하고 반환 값을 배열에 저장한다.

## 7.2 배열 요소 읽기와 쓰기

1. 배열 요소에 접근할 때는 `[]`연산자를 사용한다.

    - 대괄호 왼쪽에는 배열 참조가 있어야한다.
    - 대괄호 안에는 양의 정수로 평가되는 표현식이 있어야 한다.
    - 이 문법은 배열 요소를 읽고 쓸 때 모두 사용할 수 있다.

    ```jsx
    let a = ["world"];
    let value = a[0]; // 인덱스 0을 읽는다.
    a[1] = 3.14; // 인덱스 1에 쓴다.
    let i = 2;
    a[i] = 3; // 인덱스 2에 쓴다.
    a[i + 1] = "hello"; // 인덱스 3에 쓴다.
    a[a[i]] = a[0]; // 인덱스 0과 2를 읽은 다음, 인덱스 3에 쓴다.
    ```

1. 배열은 특별하긴 하지만 결국 객체이다.

    - 배열 요소에 접근할 때 사용하는 대괄호는 객체 프로퍼티에 접근할 때 사용하는 대괄호와 마찬가지로 동작한다.
    - 자바스크립트는 숫자인 배열 인덱스를 문자열로 변환한다.
        - 즉, 인덱스 1은 문자열 “1”이 되며, 이 문자열을 프로퍼티 이름으로 사용한다.
    - 인덱스를 숫자에서 문자열로 변환하는 것은 특별한 일이 아니며 일반 객체에서도 똑같다.
        ```jsx
        let o = {};
        o[1] = "one";
        o["1"]; // one
        ```
    - 배열 인덱스에는 음수도, 정수가 아닌 숫자도 쓸 수 있다.
        - 이렇게 하면 숫자열을 문자열로 변환하고 그 문자열을 프로퍼티 이름으로 사용한다.
        - 이런 프로퍼티는 이름이 양의 정수가 아니므로 배열 인덱스가 아니라 일반적인 객체 프로퍼티로 취급한다.
    - 양의 정수로 평가되는 문자열을 인덱스로 사용하면 객체 프로퍼티가 아니라 배열 인덱스로 취급한다.
        - 부동 소수점 숫자도 마찬가지이다.

    ```jsx
    a[-1.23] = true; // -1.23이라는 프로퍼티가 생긴다.
    a["1000"] = 0; // 배열의 1001번째 요소이다.
    a[1.0] = 1; // 배열 인덱스 1, a[1] = 1 과 같다.
    ```

## 7.3 성긴 배열

1. 성긴 배열은 인덱스가 연속적이지 않은 배열이다.
    - 일반적으로 배열의 `length` 프로퍼티는 배열에 포함된 요소의 개수이다.
    - 하지만 성긴 배열의 경우 `length` 프로퍼티의 값이 요소 개수보다 크다.
2. 충분히 성긴 배열은 일반적으로 빽빽한 배열에 비해 좀 느리지만 메모리를 효율적으로 사용하는 방법으로 구현되며, 이런 배열에서 요소를 검색하는 시간은 일반적인 객체 프로퍼티 검색에 필요한 시간과 비슷하다.
    - 현실적으로 대부분의 자바스크립트 배열은 성기지 않은 배열이다.
    - 그리고 실제로 성긴 배열을 다뤄야 할 때가 있더라도, 아마 코드에서는 그 배열을 `undefined`요소가 포함된 빽빽한 배열로 취급할 것이다.

## 7.4 배열 길이

1. 모든 배열에는 `length` 프로퍼티가 있으며 이 프로퍼티는 일반적인 자바스크립트 객체와 배열을 구분하는 특징이다.

    - 빽빽한 배열에서 `length` 프로퍼티는 배열에 포함된 요소 개수와 같다.
        - 그 값은 배열에서 가장 큰 인덱스에 `1`을 더한 값이다.
    - 성긴 배열의 `length` 프로퍼티는 포함된 요소 개수보다 크다.
    - 확실히 알 수 있는 것은 `length` 가 가장 큰 인덱스보다 더 크다는 사실이다.
        - 달리 말하자면 배열에는 `length` 보다 크거나 같은 인덱스는 존재하지 않는다.

1. 자바스크립트 배열에는 두 가지 특별한 동작이 있다.
    - 배열의 현재 길이 이상인 `i` 인덱스에 값을 할당할 때 `length` 프로퍼티를 `i + 1`로 갱신하는 동작
    - 배열의 `length` 프로퍼티를 현재 값보다 작은 양의 정수 `n`으로 지정할때 인덱스가 `n`이상인 배열 요소는 모두 삭제하는 동작
        ```jsx
        a = [1, 2, 3, 4, 5]; // 요소가 다섯 개 있는 배열로 시작한다.
        a.length = 3; // a는 이제 [1,2,3]
        a.length = 0; // 요소 전체를 삭제한다. a는 []
        a.length = 5; // 길이는 5이지만 new Array(5)와 마찬가지로 요소는 없다.
        ```
        - `length` 프로퍼티를 현재 값보다 큰 값으로 설정할 수도 있다.
            - 이렇게 해도 실제로 새 요소가 배열에 추가되는 것은 아니며 배열 마지막에 성긴 영역이 생길 뿐 이다.

## 7.5 배열 요소 추가와 삭제

1. 배열에 요소를 추가하는 가장 단순한 방법은 새 인덱스에 값을 할당하는 방법이다.

    ```jsx
    let a = [];
    a[0] = "zero";
    a[1] = "one";
    ```

    - `push()`메서드는 배열 마지막에 값을 추가한다.
        ```jsx
        let a = [];
        a.push("zero"); // 마지막에 값을 추가한다 . ['zero']
        a.push("one", "two"); // 값을 두개 더 추가한다. ['zero', 'one', 'two']
        ```
        - `push()`는 `a[a.length]`에 값을 할당하는 것과 같다.
    - `unshift()`메서드는 배열의 맨 앞에 값을 삽입하고 기존 요소를 뒤로 민다.
    - `pop()`메서드는 `push()`의 반대로 배열의 마지막 요소를 제거하고 그 값을 반환하며 배열의 길이를 1만큼 줄인다.
    - `shift()`메서드는 배열의 첫 번째 요소를 제거해 반환하며 길이를 1만큼 줄이고 나머지 요소를 모두 앞으로 당긴다.

1. `delete` 연산자로 배열 요소를 삭제 할 수도 있다.

    ```jsx
    let a = [1, 2, 3];
    delete a[2]; // 이제 a의 인덱스 2에 요소가 없다.
    2 in a; // false
    a.length; // 3 delete는 배열 길이에 영향을 주지 않는다.
    ```

    - 배열 요소를 삭제하는 것은 그 요소에 `undefined`를 할당하는 것과 비슷하다.
        - 완전히 같지는 않다.
    - 배열 요소에 `delete` 를 사용하더라도 `length` 프로퍼티는 변하지 않으면 빈 공간을 메우기 위해 요소가 이동되지도 않는다.
    - 배열 요소를 삭제하면 그 배열은 성긴 배열이 된다.

1. `legnth` 프로퍼티를 수정해서 배열의 맨 뒤에서부터 요소를 삭제할 수도 있다.

1. 배열 요소를 삽입, 삭제, 대체하는 범용 메서드인 `splice()`도 있다.

## 7.6 배열 순회

1. ES6이후 배열 요소나 이러터블 객체를 순회하는 가장 쉬운 방법은 `for/of`이다.

    - `for/of` 루프가 사용하는 내장 이터레이터는 오름차순으로 요소를 반환한다.
    - 성긴 배열도 마찬가지이며 존재하지 않는 배열 요소에 대해서는 `undefined`를 반환한다.

1. 배열에 `for/of` 루프를 적용할 때 각 요소의 인덱스가 필요하다면 `entries()` 메서드와 분해 할당을 이용하면 된다.

    ```jsx
    let letters = [..."Hello world"];
    let everyother = "";

    for (let [index, letter] of letters.entries()) {
        if (index % 2 === 0) everyother += letter; // 짝수 번째 인덱스의 글자
    }

    everyother; // "Hlowrd"
    ```

1. `forEach()`도 배열을 순회하는 좋은 방법이다.

    - 이 메서드는 `for` 루프의 변형이 아니라 배열 순회를 함수형으로 바꾼 배열 메서드이다.
    - `forEach()`는 전달받은 함수를 각 배열 요소에서 호출한다.

    ```jsx
    let letters = [..."Hello world"];

    let uppercase = "";
    letters.forEach((letter) => {
        uppercase += letter.toUpperCase();
    });

    uppercase; // "HELLO WORLD"
    ```

    - `forEach()`는 배열을 순서대로 순회하며 배열 인덱스를 함수의 두번째 인자로 전달한다.
    - for/of 루프와 달리 forEach()는 성긴 배열을 인식하고 존재하지 않는 요소에 대해서는 함수를 호출하지 않는다.

        ```jsx
        let a = [1, 2, 3];
        delete a[1];
        a.forEach((n) => {
            console.log(n);
        });

        // 1
        // 3

        let b = [1, 2, 3];
        b[1] = undefined;
        b.forEach((n) => {
            console.log(n);
        });

        // 1
        // undefined
        // 3
        ```

## 7.7 다차원 배열

1. 자바스크립트에서 다차원 배열을 직접 지원하지는 않지만 배열의 배열을 만들어 대략적으로 흉내 낼 수는 있다.
    - 내부 배열의 값에 접근할 때는 `[]`연산자를 이중으로 쓰기만 하면 된다.

## 7.8 배열 메서드

1. 배열 메서드는 몇가지 그룹으로 묶을 수 있다.

    - 배열 요소를 순회하는 이터레이터 메서드
        - 이들은 일반적으로 각 요소에 대해 함수를 호출한다.
    - 배열의 앞이나 뒤에 요소를 추가하거나 제거하는 스택, 큐 메서드
    - 큰 배열을 추출, 삭제, 삽입, 충당, 복사하는 하위 배열 메서드
    - 배열을 검색하고 정렬하는 메서드

    ### 7.8.1 배열 이터레이터 메서드

    1. 메서드는 배열 요소를 순서대로 함수에 전달하는 방식으로 동작하며 배열 요소를 순회, 변환, 필터, 체크, 축소할 수 있다.

        - 이러한 메서드에 대한 몇가지 일반화
            - 모두 첫번째 인자로 함수를 받으며 각 배열 요소(또는 일부 요소)에 대해 그 함수를 한 번씩 호출한다.
            - 성긴 배열이라면 존재하지 않는 요소에 대해서는 함수를 호출하지 않는다.
            - 대부분의 경우 이 함수는 배열 요소의 값, 인덱스, 배열 자체 세가지 인자를 받는다.

    1. 다음 설명하는 이터레이터 메서드 대부분은 선택 사항으로 두번째 인자를 받는다.

        - 두번째 인자를 지정했다면 첫번째 인자인 함수는 자신이 그 두번째 인자의 메서드인 것처럼 호출된다.
            - 즉 두번째 인자가 함수의 `this`가 된다.

    1. 여기서 설명하는 메서드 중 원래 배열을 수정하는 메서드는 없다.

        - 물론 전달하는 함수가 원래 배열을 수정할 수는 있다.

        ### forEach()

        1. `forEach()` 메서드는 배열을 순회하며 각 요소에서 함수를 호출한다.

            - 첫번째 인자는 함수다.
                - `forEach()`는 배열 요소의 값, 배열 요소의 인덱스, 배열 자체를 인자로 전달해 이 함수를 호출한다.
            - 배열 요소의 값에만 관심이 있다면 인자 하나만 받는 함수를 작성하고 나머지는 무시해도 된다.

            ```jsx
            let data = [1, 2, 3, 4, 5],
                sum = 0;

            // 배열 요소의 합을 계산한다.
            data.forEach((value) => {
                sum += value;
            }); // sum == 15

            // 배열 요소를 각각 증가시킨다.
            data.forEach(function (v, i, a) {
                a[i] = v + 1;
            }); // data == [2,3,4,5,6]
            ```

            - `forEach()`에서 모든 요소를 함수에 전달하기 전에 반복을 멈추는 방법은 없다.

        ### map()

        1. `map()` 메서드는 각 배열 요소를 함수에 전달해 호출하며, 그 함수가 반환한 값으로 이루어진 배열을 반환한다.

            ```jsx
            let a = [1, 2, 3];
            a.map((x) => x * x); // [1,4,9]
            ```

        1. `map()`에 전달하는 함수는 `forEach()`에 전달하는 함수와 같은 방법으로 호출된다.
            - 하지만 `map()`메서드에 전달하는 함수는 값을 반환해야 한다.
            - `map()`은 새 배열을 반환하며 기존 배열은 수정하지 않는다.
            - 성긴 배열이라면 존재하지 않는 요소에 대해서는 함수를 호출하지 않지만, 반환된 배열 역시 같은 위치에 갭이 있으며 길이 또한 같다.

        ### filter()

        1. `filter()` 메서드는 기존 배열의 일부만 포함하는 부분 집합을 반환한다.

            - 전달하는 함수를 기준으로 하며 이 함수는 `true` 또는 `false`를 반환한다.
            - 반환 값이 `true`이거나 `true`로 변환될 수 있는 값이면, 해당 요소는 반환되는 배열에 포함된다.

            ```jsx
            let a = [5, 4, 3, 2, 1];
            a.filter((x) => x < 3); // [2,1] 3미만의 값
            a.filter((x, i) => i % 2 === 0); // [5, 3, 1]; 인덱스가 짝수인 값
            ```

        1. `filter()`는 성긴 배열에서 존재하지 않는 값은 건너뛰며, 반환하는 배열은 항상 빽빽한 배열이다.
            - `filter()`를 써서 갭과 함께 `undefined`, `null` 요소도 제거할 수 있다.
                ```jsx
                a = a.filter((x) => x !== undefined && x !== null);
                ```

        ### find()와 findIndex()

        1. `find()`와 `findIndex()` 메서드는 판별 함수에서 `true` 같은 값을 반환하는 요소를 찾아 배열을 순회한다는 점은 `filter()`와 같다.

            - 하지만 `filter()`와 달리 이들 메서드는 기준을 만족하는 첫 번째 요소를 찾는 즉시 순회를 멈춘다.
            - 만족하는 요소를 찾으면 `find()`는 그 요소를, `findIndex()`는 그 요소의 인덱스를 반환한다.
            - 만족하는 요소를 찾지 못하면 `find()`는 `undefined`를 `findIndex()`는 `-1`을 반환한다.

            ```jsx
            let a = [1, 2, 3, 4, 5];
            a.findIndex((x) => x === 3); // 2
            a.findIndex((x) => x < 0); // -1
            a.find((x) => x % 5 === 0); // 5
            a.find((x) => x % 7 === 0); // undefined
            ```

        ### every()와 some()

        1.
