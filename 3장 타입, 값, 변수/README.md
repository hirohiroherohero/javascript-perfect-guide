## 3.1 개요와 정의

1. 자바스크립트 타입은 기본 타입과 객체 타입으로 나뉜다.

    - 기본 타입
        - number
        - string
        - boolean
        - null
        - undefined
        - symbol
    - 객체 타입
        - Array
        - Object
        - Date ( 날짜와 시간을 표현 )
        - RegExp ( 텍스트 패턴 )
        - Map ( 키와 값의 연결 )
        - Set ( 값의 집합 )
        - etc…

1. 자바스크립트의 함수와 클래스

    - 자바스크립트의 함수와 클래스는 그 자체가 값이므로 프로그램에서 조작할 수 있다.
    - 함수와 클래스도 특별한 객체다.

1. [가비지 컬렉션](https://ko.javascript.info/garbage-collection)

    - 자바스크립트 인터프리터는 자동으로 가비지 컬렉션을 수행해 메모리를 관리한다.
        - 따라서 객체나 다른 값을 직접 파괴하거나 할당 해제할 필요가 없다.
        - 어떠한 값을 더 이상 참조하지 않으면 인터프리터는 그 값이 차지하고 있던 메모리를 자동으로 다시 확보한다.

1. 자바스크립트는 객체 지향 프로그래밍 스타일을 지원한다.

    - 대략적으로 말하면, 함수가 다양한 타입의 값을 다루는 것이 아니라 객체(타입 자체)에 그 값을 다루는 메서드를 정의한다.

    ```jsx
    a.sort(); // sort(a)의 객체 지향 버전
    ```

1. 자바스크립트의 기본 타입은 불변(immutable)이며 객체 타입은 가변(mutable)이다.

    - 문자열을 문자의 배열로 생각한다면?
        - 인덱스를 통해 문자열에 틀어있는 텍스트에 접근할 수는 있지만, 기존 문자열의 텍스트를 바꿀 방법은 없다.

1. 프로그램에서는 상수와 변수의 이름을 통해 값을 참조한다.
    - 상수는 `const` 로 선언
    - 변수는 `let` 으로 선언
    - 선언할 때 어떤 값이 할당되는지 명시하지 않는다.

## 3.2 숫자

1. 자바스크립트의 숫자 타입인 Number는 정수와 함께 실수를 대략적으로 표현한다.
    - 자바스크립트 프로그램에 직접 기입한 숫자를 숫자 리터럴이라고 부른다.

### 3.2.1 정수 리터럴

1. 자바스크립트 프로그램에서 10진 정수는 연속된 숫자로 표현한다.

    ```jsx
    0;
    3;
    10000000;
    ```

### 3.2.2 부동 소수점 리터럴

1. 부동 소수점 리터럴에는 소수점이 포함될 수 있다.

    ```jsx
    3.14;
    2345.6789;
    0.33333333;
    ```

### 3.2.3 자바스크립트의 산술 연산

1. 자바스크립트는 산술 연산자를 통해 숫자를 조작한다.

    - +
    - -
    - *
    - /
    - % (나머지)

1. 자바스크립트는 [Math](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Math) 객체의 프로퍼티로 정의된 함수와 상수를 통해 더 복잡한 수학 계산을 지원한다.

1. 자바스크립트는 산술 연산 과정에서 0으로 나누거나 오버플로, 언더플로가 발생해도 에러를 일으키지 않는다.

    - 계산 결과가 표현할 수 있는 가장 큰 숫자보다 큰 경우 `Infinity` 를 반환
    - 음수의 절대값이 표현할 수 있는 가장 큰 음수의 절대값보다 큰 경우 `-Infinity` 를 반환
    - 무한한 값에 어떠한 값을 더하거나, 빼거나, 곱하거나, 나누더라도 무한한 값이다.
        - 부호는 바뀔수 있다.

1. 언더플로

    - 계산 결과가 자바스크립트가 표현할 수 있는 가장 작은 숫자보다도 0에 가까울 때 일어난다.
    - 자바스크립트는 이런 경우 0을 반환한다.

1. 자바스크립트는 0으로 나눠도 에러가 일어나지 않는다.
    - 무한대 또는 음의 무한대를 반환할 뿐이다.
    - 다만 0을 0으로 나누는 경우는 정의되어 있지 않으므로, `NaN`를 반환한다.
        - 무한대를 무한대로 나누거나
        - 음수의 제곱근을 구하거나
        - 숫자가 아니고 숫자로 변환할 수 없는 피연산자에 산술 연산자를 적용하려 할 때도 `NaN`을 반환.
1. 자바스크립트의 `Infinity` 와 `NaN` 는 전역 상수이다.

1. NaN

    - `NaN` 값은 자기 자신을 포함해 어떤 값과도 같지 않다는 특징이 있다.

    ```jsx
    const x = NaN;
    x === NaN; // false
    x != x; // false
    Number.isNaN(x); // true
    ```

### 3.2.4 이진 부동 소수점 숫자와 반올림 오류

1. 자바스크립트를 비롯해 최신 프로그래밍 언어에서 사용하는 IEEE 754 부동 소수점 표현은 이진 표현이다.

    - 이진 부동 소수점 표현은 0.1 같은 단순한 숫자를 정확히 표현하지 못하고 아주 가깝게 표현한다.

    ```jsx
    let x = 0.3 - 0.2;
    let y = 0.2 - 0.1;
    x === y; // false
    x === 0.1; // false
    y === 0.1; // true
    ```

    - 반올림 오류 때문에 0.3과 0.2의 차이의 근삿값은 0.2와 0.1의 차이의 근삿값과 같지 않다.
    - 부동 소수점 근삿값 때문에 프로그램에 문제가 생긴다면 정수로 변환하는 것을 고려하자.
        - 0.1달러 → 10센트

### 3.2.5 BigInt로 임의 정확도를 부여한 정수

1. `BigInt`는 ES2020에서 정의한 자바스크립트의 최신 기능 중 하나이다.
    - `BigInt` 는 값이 정수인 숫자 타입이다.
    - 다른 프로그래밍 언어나 API와의 호환에 필요한 64비트 정수를 표현하기 위해 추가됐다.

## 3.3 텍스트

<aside>
💡 자바스크립트에서 텍스트를 표현하는 타입은 문자열이다.
문자열은 16비트 값이 순서에 따라 이어진 형태이며, 기본 값이므로 불변이다.
문자열의 길이(Length)는 그 문자열에 포함된 16비트 값의 개수이다.

</aside>

### 3.3.4 템플릿 리터럴

1. ES6부터는 백틱으로 감싼 문자열 리터럴을 사용할 수 있다.

    ```jsx
    let s = `hello world`;
    ```

    - 이것을 템플릿 리터럴이라고 한다.

2. 태그된 템플릿 리터럴

    - 백틱 바로 앞에 함수 이름(태그)이 있으면 템플릿 리터럴의 텍스트와 표현식 값이 함수에 전달된다.

    ```jsx
    `\n`.length; // 1
    String.raw`\n`.length; // 2
    ```

    - 백틱 문자가 여닫는 괄호를 대신했다.
    - 템플릿 태그 함수를 자유롭게 정의할 수 있다는 것은 자바스크립트의 강력한 기능 중 하나이다.

## 3.4 boolean 값

1. 예약어인 `true`와 `false` 단 두가지 값만 존재한다.

1. `falsy` 값
    - undefined
    - null
    - 0 (-0)
    - NaN
    - 빈 문자열

## 3.5 null과 undefined

1. null

    - 값이 없음을 나타낼때 사용하는 값
    - `typeof null = “object”`
    - ‘값이 없다’는 의미로 사용
    - 프로그램 레벨이고 정상적이거나 예측된 상황에서 값이 없는 것이라 간주

1. undefined
    - 초기화되지 핞은 변수의 값
    - 존재하지 않는 객체 프로퍼티나 배열 요소에 접근했을때 반환되는 값
    - 값을 명시적으로 반환하지 않는 함수의 반환 값
    - 전달되지 않는 인자의 값
    - 미리 정의된 전역 상수
    - `typeof undefined = “undefined”`
    - 예측되지 않았거나 에러 비슷한 상황에서 값이 없는 것이라 간주

## 3.6 심벌

1. 심벌은 문자열이 아닌 프로퍼티 이름으로 ES6에서 추가됐다.
    - 프로퍼티의 이름은 일반적으로 문자열인데 ES6이후에는 심벌 역시 같은 목적으로 사용할 수 있다.
2. 심벌 타입에는 리터럴 문법이 없다.

    - 심벌 값을 가져올 때는 `Symbol()` 함수를 호출한다.
    - 이 함수는 절대 같은 값을 반환하지 않는다.
        - 같은 인자로 호출하더라도 다른 값을 반환한다.
        - 즉, `Symbol()` 을 호출해 값을 얻었다면 객체의 기존 프로퍼티를 같은 이름으로 덮어 쓸 염려 없이 그 값을 프로퍼티 이름으로 추가할 수 있다는 뜻이다.

3. 전역 심벌 레지스트리

    - `Symbol.for()` 함수는 문자열 인자를 받고 그 문자열과 연관된 심벌 값을 반환한다.
        - 그 문자열과 연관된 심벌이 존재하지 않으면 새 심벌을 생성해 반환하고, 존재하면 기존 심벌을 반환한다.
    - `Symbol()` 은 절대 같은 값을 반환하지 않지만 `Symbol.for()` 는 같은 문자열로 호출 했을때 항상 같은 값을 반환한다.
    - 반환된 심벌에 `Symbol.keyFor()` 를 호출하면 해당 문자열을 얻을 수 있다.

    ```jsx
    let s = Symbol.for("shared");
    let t = Symbol.for("shared");

    s === t; // true
    s.toString(); // "Symbol("shared")"
    Symbol.keyFor(t); // "shared"
    ```

## 3.7 전역 객체

1. 전역 객체는 일반적인 자바스크립트 객체지만 아주 중요한 목적에 쓰인다.

    - 이 객체의 프로퍼티는 전역으로 정의된 식별자이며 모든 자바스크립트 프로그램에서 사용할 수 있다.

1. 자바스크립트 인터프리터를 시작할 때마다 (또는 웹 브라우저가 새 페이지를 로드할 때마다) 다음과 같은 프로퍼티를 가진 새 전역 객체를 생성한다.

    - `undefined`, `Infinity`, `NaN` 같은 전역 상수
    - `isNaN()`, `parseInt()`, `eval()` 같은 전역 함수
    - `Date()`, `RegExp()`, `String()`, `Object()`, `Array()` 같은 생성자 함수
    - `Math`와 `JSON` 같은 전역 객체

    → 전역 객체의 초기 프로퍼티는 예약어가 아니지만 예약어로 간주해야 한다.

1. 노드의 전역 객체에는 `global` 프로퍼티가 있으며 그 값은 전역 객체 자체이다.

    - 노드 프로그램에선 `global`이라는 이름으로 전역 객체를 참조할 수 있다.

1. 웹 브라우저에는 `Window` 객체가 모든 자바스크립트 코드의 전역 객체이다.

    - `Window` 객체에는 자신을 참조하는 `window` 프로퍼티가 있고 이것을 통하여 전역 객체를 참조할 수 있다.

1. ES2020에서 정의한 `globalThis`는 어떤 환경에서든 전역 객체를 참조하는 표준이다.

## 3.8 불변인 기본 값과 가변인 객체 참조

1. 기본 타입

    - 불변값
    - 문자열의 메소드는 새 문자열을 반환하는 것

    ```jsx
    let s = "hello";
    s.toUpperCase();
    s; // 'hello' : 원래 문자열은 변하지 않는다.
    ```

1. 객체 타입

    - 가변값

    ```jsx
    let o = { x: 1 };
    o.x = 2; // 프로퍼티 값을 바꿔 객체를 변경
    o.y = 3; // 새 프로퍼티를 추가하여 다시 변경

    let a = [1, 2, 3];
    a[0] = 0; // 배열 요소의 값을 변경
    a[3] = 4; // 배열에 새 요소 추가
    ```

    - 객체 타입은 참조이며, 객체는 참조로 비교한다.
        - 두 객체 값이 같다는 말은 두 값이 같은 객체를 참조할 때만 성립한다.

    ```jsx
    let o = { x: 1 };
    let p = { x: 1 };
    o === p; // false

    let a = [];
    let b = [];
    a === b; // false

    let x = [];
    let y = x;
    y[0] = 1;
    a[0]; // 1
    a === b; // true
    ```

    - 객체나 배열을 변수에 할당하는 것은 참조를 할당하는 것이다.
        - 사본이 새로 생기는 것이 아니다.
        - 객체나 배열의 사본을 만들기 위해서는 반드시 객체 프로퍼티나 배열 요소를 직접 복사해야 한다.
        ```jsx
        let a = ["a", "b", "c"]; // 복사할 배열
        let b = []; // 복사해 넣을 대상
        for (let i = 0; i < a.length; i++) {
            b[i] = a[i]; // a의 각 인덱스에 대해 a의 요소를 b에 복사
        }
        let c = Array.from(b); // ES6에서는 Array.from()으로 배열 복사 가능
        ```
    - 별개의 객체나 배열을 비교할 때는 양쪽의 프로퍼티나 요소를 비교해야 한다.
        ```jsx
        function equalArray(a, b) {
            if (a === b) return true; // 같은 배열을 참조한다면 true
            if (a.length === b.length) return false; // 크기가 다르면 false
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false; // 요소 중 어느 하나라도 다르면 false
            }
            return true; // 모두 같다면 true
        }
        ```

## 3.9 타입 변환

1. 자바스크립트는 값의 타입을 강제하지 않고 필요에 맞게 값을 변환한다.

    ```jsx
    10 + "object"; // "10 object"
    "7" * "4"; // 28
    let n = 1 - "x"; // NaN
    n + " object"; // "NaN object"
    ```

### 3.9.3 객체를 기본 값으로 변환

1. 자바스크립트 명세에는 객체를 기본 값으로 변환하는 세 가지 기본적인 알고리즘이 정의되어 있다.

    > 문자열 선호: 기본 값을 반환할 때 문자열로 변환할 수 있다면 문자열 값을 우선한다.
    >
    > 숫자 선호: 기본 값을 반환할 때 숫자로 변환할 수 있다면 숫자 값을 우선한다.
    >
    > 선호 없음: 어떤 기본 타입을 선호하는지 정해 놓지 않았으며 클래스에서 변환 방법을 정의할 수 있다.

    - `Date`를 제외한 모든 타입이 숫자 선호 알고리즘을 적용한다.
        - `Date`는 문자열 선호를 적용한다.

2. `valueof()`
    - 객체를 표현하는 기본 값이 존재한다면 그 값으로 객체를 변환한다.
        - but, 객체는 복합된 형태이며 대부분의 객체는 단일한 기본값으로 표현하는 것이 불가능하다.
        - 따라서, 기본 `valueof()` 메서드는 기 본값이 아니라 객체 자체를 반환한다.
    - 문자열, 숫자, boolean의 래퍼 클래스의 `valueof()` 메서드는 그냥 그 기본값을 반환한다.
    - 배열, 함수, 정규 표현식은 기본 메서드를 상속한다.
        - 이들 타입의 인스턴스에서 `valueof()` 를 호출하면 객체 자체를 반환한다.
    - Date 클래스의 `valueof()` 메서드는 날짜를 내부적으로 저장하는 형식인, 1970년 1월 1일로부터 경과된 밀리초를 반환한다.
3. 객체를 기본 값으로 변환하는 세가지 알고리즘의 동작 방식

    <aside>
    💡 여기서 설명할 규칙은 자바스크립트 내장 타입과 여러분이 정의하는 클래스의 기본 규칙이다.

    </aside>

    - 문자열 선호 알고리즘
        - 먼저 `toString()` 메소드를 시도
            - 이 메서드가 정의되어 있고 기본 값을 반환한다면 자바스크립트는 그 값을 사용한다.
                - 그 기본 값이 문자열이 아니더라도 그대로 사용!!
        - `toString()`이 존재하지 않거나 객체를 반환한다면 `valueOf()` 메서드를 시도
            - 이 메서드가 존재하고 기본 값을 반환한다면 그 값을 사용한다.
            - 그렇지 않다면 `TypeError` 발생!
    - 숫자 선호 알고리즘
        - 문자열 선호 알고리즘과 비슷하지만, `valueOf()` 를 먼저 시도하고 `toString()` 을 두번째로 시도한다!
    - 선호 없음 알고리즘
        - 변환하는 객체의 클래스에 따라 다르게 동작한다.
            - 객체가 `Date` 객체일 경우 문자열 선호 알고리즘을 사용한다.
            - 그 외의 객체에서는 숫자 선호 알고리즘을 사용한다.
    - 숫자 선호 알고리즘이 빈 배열을 숫자 0으로 변환하고 요소가 단 하나 있는 배열고 숫자로 변환하는 이유!!
        ```jsx
        Number([]); // 0
        Number([99]); // 99
        ```
        - 객체를 숫자로 변환할 때는 먼저 숫자 선호 알고리즘을 써서 객체를 기본 값으로 변환하고 그 결과인 기본 값을 숫자로 변환한다.
            - 숫자 선호 알고리즘은 먼저 valueOf()를 시도하고 실패할 경우 toString()을 시도한다.
            - 하지만 배열은 기본 valueOf() 메서드를 상속하는데, 이 메서드는 기본 값을 반환하지 않는다.
            - 따라서, 배열을 숫자로 변환하려 하면 결국 toString() 메서드를 호출한다.
        - 빈 배열은 빈 문자열로 변환된다.
            - 그리고 빈 문자열은 숫자 0으로 변환된다.
        - 요소가 하나뿐인 배열은 그 요소가 변환되는 것과 같은 문자열로 변환된다.
            - 배열 요소가 숫자 하나뿐이라면 그 숫자가 먼저 문자열로 변환되고 다시 숫자로 변환된다.

### 3.10 변수 선언과 할당

<aside>
💡 이름 또는 식별자를 사용해 값을 표현하는 것은 컴퓨터 프로그래밍의 기본적인 기술 중 하나이다.
값에 이름을 부여하면 프로그램에서 그 값을 참조하고 사용할 수 있다.
이런 과정을 일반적으로 변수에 값을 할당한다고 말한다.

</aside>

1. ES6 이후부턴 `let`과 `const`를 사용해 변수와 상수를 선언한다.

    - `let`
        - 변수
        - 변경 가능
        - 초기값을 할당하지 않으면 할당할 때 까지 `undefined`로 남는다.
    - `const`
        - 상수
        - 변경 불가
        - 선언 할때 반드시 값을 할당하여 초기화 해야 한다.

1. 변수와 상수 스코프

    - 변수의 스코프는 프로그램 소스 코드에서 해당 변수가 정의된 영역이다.
        - `let`과 `const`로 선언한 변수와 상수는 블록 스코프를 가진다.
            - 그 블록 스코프 안에서만 해당 변수와 상수가 유효하다는 뜻!
        - 자바스크립트의 클래스와 함수 정의는 블록이고 `if/else`문, `while`루프, `for`루프 등의 바디 역시 블록이다.
        - 대략적으로, 중괄호 안에서 변수나 상수를 선언하면 그 중괄호가 변수와 상수가 정의된 영역이다.
    - 선언이 어떤 코드 블록에도 속하지 않고 최상위 레벨에 있을 경우 이를 전역 변수 또는 상수라고 부른다.

1. `var`

    - 호이스팅
        - `var`로 변수를 선언하면 이 선언문은 함수의 맨 위로 끌여올려진다.
            - 변수의 초기화는 코드상의 위치에 그대로 존재하지만 정의만 함수 맨 위로 올라간다.
            - 따라서 `var`로 선언한 변수는 함수 어디에서든 에러 없이 사용할 수 있다.
        - `let`으로 변수를 선언하면 `undefined` 값이 나타나고 끝나는게 아니라 실제로 에러가 일어난다.

1. 분해 할당
    - ES6에서는 선언과 할당을 합친 일종의 복합 문법을 도입했으며 이를 분해 할당이라고 부른다.
        - 분해할당에서는 할당 연산자의 오른쪽에 있는 값은 배열이나 객체 같은 구조적인 값
        - 왼쪽에 있는 값은 하나 이상의 변수 이름이며 배열이나 객체 리터럴 문법을 쓴다.
        - 분해 할당이 일어나면 오른쪽 값에서 하나 이상의 값을 추출(분해)해서 왼쪽에 있는 변수에 할당한다.
        ```jsx
        let [x, y] = [1, 2];
        [x, y] = [x + 1, y + 1];
        [x, y] = [y, x];
        [x, y]; // [3,2]
        ```
    - 마지막 변수 이름앞에 점 세 개(…)를 써서 배열을 분해하고 남은 값을 변수 하나에 모을 수 있다.
        ```jsx
        let [x, ...y] = [1, 2, 3, 4]; // y == [2,3,4]
        ```
    - 분해 할당은 중첩된 배열에서도 사용할 수 있다.
        ```jsx
        let [a, [b, c]] = [1, [2, 2.5], 3]; // a == 1, b == 2, c == 2.5
        ```
