1. 함수는 한 번 정의하면 몇 번이고 호출할 수 있는 자바스크립트 코드 블록이다.

    - 자바스크립트 함수는 매개변수화 된다.
        - 함수 정의에는 매개변수라고 불리는 식별자 리스트가 있는데, 이들은 함수 바디에서 로컬변수처럼 동작한다.
    - 함수를 호출할 때는 매개변수에 값을 전달하는데 이를 인자라고 한다.
        - 함수는 보통 인자를 사용해 반환 값을 도출하며, 이 값이 함수 호출 표현식의 값이 된다.
    - 매개변수 외에도 각 호출에는 호출 컨텍스트가 존재하며 이것이 `this` 키워드의 값이다.

1. 객체 프로퍼티로 할당된 함수를 객체의 메서드라고 부른다.
    - 객체를 통해 함수를 호출하면 그 객체가 호출 컨텍스트, 즉 함수의 `this` 값이다.
    - 객체를 새로 만들 목적으로 설계한 함수를 생성자라고 한다.
1. 자바스크립트 함수는 객체이며 프로그램에서 조작할 수 있다.

    - 자바스크립트는 함수를 변수에 할당하거나 다른 함수에 전달할 수 있다.
    - 함수는 객체이므로 프로퍼티를 정의할 수 있고 함수의 메서드를 호출하는 것도 가능하다.

1. 자바스크립트 함수는 다른 함수 안에서 정의할 수 있으며, 이렇게 정의된 함수는 자신의 정의된 스코프의 변수에 접근할 수 있다.
    - 이런 의미에서 자바스크립트함수는 클로저이다.
    - 클로저를 통해 중요하고 강력한 프로그래밍 기법을 사용할 수 있다.

## 8.1 함수정의

1. 자바스크립트 함수를 정의하는 가장 단순한 방법은 `function` 키워드이다.

    - 이 키워드 선언으로도, 표현식으로도 사용할 수 있다
    - ES6에서는 `function` 키워드 없이 함수를 정의하는 새로운 방법인 ‘화살표 함수’를 도입했다.
        - 이 문법은 아주 간결하며, 함수를 다른 함수에 인자로 전달할 때 특히 유용하다.

1. 객체 리터럴과 클래스 정의에는 메서드를 정의하는 단축 문법이 있다.

    - 이 단축 문법은 함수 정의 표현식을 사용하고 `name: value` 객체 리터럴 문법으로 그 표현식을 객체 프로퍼티에 할당하는 것과 동등하다.
    - 객체 리터럴에서 키워드 `get`과 `set`을 써서 프로퍼티 게터와 세터 메서드를 정의할 수도 있다.

1. `Function()` 생성자를 사용해 함수를 정의할 수도 있다.

### 8.1.1 함수 선언

1. 함수 선언은 `function` 키워드 뒤에 다음 세가지 구성요소를 쓴다.

    - 함수 이름이 될 식별자, 이름은 함수 선언에서 뺄 수 없는 부분이다.
        - 이 이름은 변수 이름으로 쓰이며, 새로 정의된 함수 객체가 이 변수에 할당된다.
    - 괄호로 감싸고 콤마로 구분한 0개 이상의 식별자 리스트, 이 식별자들은 함수 매개변수 이름이며 함수 바디 안에서 로컬 변수로 동작한다.
    - 중괄호로 감싼 0개 이상의 자바스크립트 문, 이 문이 함수 바디이며 함수를 호출 할 때마다 실행된다.

    ```jsx
    function add(x, y) {
        return x + y;
    }
    ```

1. 함수 선언에서 이해해야 할 중요한 점은 함수의 이름이 변수이며 그 값은 함수 자체라는 점이다.

    - 함수 선언문은 자신을 포함하는 스크립트, 함수, 또는 블록 맨 위로 끌어올려지므로 함수 선언문으로 정의한 함수는 정의하기 전에도 호출할 수 있다.
    - 블록 안에서 선언된 함수는 모두 그 블록 전체에 존재하며, 자바스크립트 인터프리터가 해당 블록의 코드를 실행하기 전에 정의된다고 봐도 된다.

1. ES6 스트릭트 모드에서는 블록 안에서 함수를 선언할 수 있다.
    - 이렇게 블록 안에서 정의된 함수는 해당 블록 안에서만 존재하며 블록 바깥에서는 볼 수 없다.

### 8.1.2 함수 표현식

1. 함수 표현식은 함수 선언과 거의 비슷하지만, 더 큰 표현식이나 문의 일부로서 존재하고 이름을 붙이지 않아도 된다는 점이 다르다.

    ```jsx
    const add = function (x, y) {
        return x + y;
    };
    ```

    - 함수 표현식은 변수를 선언하지 않는다.
        - 새로 정의한 함수 객체를 나중에 다시 참조해야 한다면, 프로그래머의 선택에 따라 변수 또는 상수에 할당한다.
    - 함수 표현식에 이름이 있으면, 로컬 함수 스코프에서 그 이름으로 함수 객체를 참조한다.
        - 즉, 함수 이름은 함수 안에서 로컬 변수가 된다.

1. 함수 선언으로 함수 f()를 정의하는 것과 표현식으로 함수를 생성하고 변수 f에 할당하는 것 사이에는 중요한 차이가 있다.
    - 선언 형태를 사용하면 함수 객체는 자신을 포함하는 코드가 실행되기 전에 존재하며 정의하기 전에 호출할 수 있다.
        - 표현식으로 정의된 함수는 이렇게 동작하지 않는다.
    - 함수를 정의하는 표현식이 실제로 평가되기 전에는 함수가 존재하지 않는다.
    - 또한 함수를 호출하려면 반드시 함수를 참조할 수 있어야 하는데, 표현식으로 정의된 함수는 변수에 할당하기 전에는 참조할 수 없다.
    - 따라서 표현식으로 정의된 함수는 정의하기 전에 호출할 수 없다.

### 8.1.3 화살표 함수

1. ES6 이후에는 화살표 함수라는 간결한 문법으로 함수를 정의할 수 있다.

    - 이 문법은 ‘⇒(화살표)’를 사용해 함수 매개변수와 함수 바디를 구분한다.
    - 화살표 함수는 문이 아니라 표현식이므로 `function` 키워드는 사용하지 않으며 함수 이름도 필요 없다.
    - 화살표 함수의 일반적인 형태는 괄호 안에 콤마로 구분한 매개변수 리스트를 쓰고, 그 뒤에 ⇒ 화살표와 중괄호로 감싼 함수 바디를 쓰는 형태이다.
    - 함수 바디가 `return`문 하나라면 `return` 키워드와 중괄호를 모두 생략하고 값을 반환하는 표현식 하나만으로 함수 바디를 구성할 수 있다.
    - 매개변수가 정확히 하나라면 매개변수를 감싼 괄호도 생략할수 있다.
        - 하지만 매개변수를 받지 않을 때는 반드시 빈 괄호를 써야 한다.
    - 또한 화살표 함수의 바디가 `return` 문 하나라고 해도, 반환할 표현식이 객체 리터럴이라면 객체 리터럴을 명시적으로 괄호 안에 써서 함수 바디의 중괄호와 객체 리터텉의 중괄호를 혼동하지 않게 해야 한다.

    ```jsx
    const add = (x, y) => {
        return x + y;
    };

    const add = (x, y) => x + y;

    const polynomial = (x) => x * x + 2 * x + 3;

    const f = (x) => {
        return { value: x };
    };

    const g = (x) => ({ value: x });
    ```

2. 화살표 함수는 문법이 간결하므로 함수를 다른 함수에 전달할 때 이상적이다.

    - `map(), filter(), reduce()` 같은 배열 메서들를 사용할 때

3. 다른 방법으로 정의된 함수는 자신만의 호출 컨텍스트를 정의하지만, 화살표 함수는 자신의 정의된 함수의 `this` 키워드 값을 상속한다는 결정적인 차이가 있다.
    - 이것은 화살표 함수에서 중요하고 아주 유용한 기능이다.
    - 화살표 함수는 `prototype` 프로퍼티가 없으므로 새로운 클래스의 생성자 함수로 사용할 수 없다.

### 8.1.4 중첩된 함수

1. 자바스크립트에서는 다른 함수 안에 함수를 중첩할 수 있다.

    ```jsx
    function hypotenuse(a, b) {
        function square(x) {
            return x * x;
        }
        return Math.sqrt(square(a) + square(b));
    }
    ```

    - 중첩된 함수에서 흥미로운 것은 변수 스코프 규칙이다.
        - 중첩된 함수는 자신을 포함하는 함수(들)의 매개변수와 변수에 접근할 수 있다.
        - 위 예제에서 내부 함수 `square()`는 외부 함수 `hypotenuse()`에서 정의된 매개변수 a와 b를 읽고 쓸 수 있다.

## 8.2 함수 호출

1. 함수 바디를 구성하는 자바스크립트 코드는 함수를 정의할 때가 아니라 호출할 때 실행된다.

    - 자바스크립트 함수는 다섯가지 방법으로 호출할 수 있다.
        - 함수로 호출
        - 메서드로 호출
        - 생성자로 호출
        - `call(), apply()` 메서드를 통해 간접적으로 호출
        - 자바스크립트 언어 기능을 통한 묵시적 호출

    ### 8.2.1 함수로 호출

    1. 함수는 호출 표현식을 통해 함수 또는 메서드로 호출된다.

        - 호출 표현식은 함수 객체로 평가되는 표현식 뒤에 콤마로 구분한 0개 이상의 인자 표현식 리스트를 괄호로 감싼 형태이다.
        - 함수 표현식이 프로퍼티 접근 표현식이라면 즉, 해당 함수가 객체 프로퍼티거나 배열 요소라면, 이 표현식은 메서드 호출 표현식이다.

        ```jsx
        printprops({ x: 1 });
        let total = distance(0, 0, 2, 1) + distance(2, 1, 3, 5);
        ㄹ;
        ```

        - 괄호 안에 들어 있는 각 인자 표현식을 호출 시점에서 평가한 값이 인자가 된다.
            - 함수 바디에서는 각 매개변수가 이에 대응하는 인자로 평가된다.

    2. 일반적인 함수 호출에서는 함수의 반환 값이 호출 표현식의 값이다.

        - `return`문을 만나지 않은 채 인터프리터가 함수의 끝에 도달하면 반환 값은 `undefined`이다.
        - 인터프리터가 `return`문을 실행해서 함수를 종료한다면 `return`문 다음에 있는 표현식의 값이 함수의 반환 값이며, `return`문에 값이 없다면 `undefined`가 함수의 반환값이다.

    3. 조건부 호출

        - ES2020에서는 함수 표현식과 여는 괄호 사이에 `?.`를 넣어서 함수가 `null`이나 `undefine`가 아닌 경우에만 호출하게 할 수 있다.
            - 즉 부수효과가 없다고 가정하면 표현식 `f?.(x)`는 다음 코드와 동등하다.
            ```jsx
            f !== null && f !== undefined ? f(x) : undefined;
            ```

    4. 일반 모드에서 함수의 호출 컨텍스트(`this`)는 전역 객체이다.

        - 스트릭트 모드의 호출 컨텍스트는 `undefined`이다.
            - 단 화살표 문법으로 정의한 함수는 항상 자신이 정의된 곳의 `this` 값을 상속한다.
        - 메서드가 아니라 함수로 호출되도록 설계된 함수는 일반적으로 `this` 키워드를 전혀 사용하지 않는다.

    5. 재귀함수와 스택
        - 트리기반 데이터 구조 같은 일부 알고리즘은 재귀 함수를 사용해 아주 명쾌하게 구현할 수 있다.
        - 하지만 재귀 함수를 만들 때는 메모리를 고려하는 것이 중요하다.
            - 함수 A가 함수 B를 호출하고 다시 함수 B가 함수 C를 호출하는 상황에서 자바스크립트 인터프리터는 세 함수의 실행 컨텍스트를 모두 추적해야 한다.
        - 실행컨텍스트를 스택이라고 생각하면 함수가 다른 함수를 호출하면 새 실행 컨텍스트를 스택에 추가하고, 실행을 마치면 그 실행 컨텍스트 객체를 스택에서 꺼낸다.
            - 콜 스택도 메모리를 사용한다.
        - 최신 하드웨어에서 일반적으로 재귀 함수가 자신을 수백 번 호출하는 정도는 문제가 되지 않는다.
            - 하지만 함수가 자기 자신을 수만 번 호출한다면 콜 스택 크기가 한도에도 도달했다는 에러가 난다.
